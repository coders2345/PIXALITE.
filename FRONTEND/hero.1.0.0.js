!function(e){var t={};function n(c){if(t[c])return t[c].exports;var l=t[c]={i:c,l:!1,exports:{}};return e[c].call(l.exports,l,l.exports,n),l.l=!0,l.exports}n.m=e,n.c=t,n.d=function(e,t,c){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:c})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var c=Object.create(null);if(n.r(c),Object.defineProperty(c,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var l in e)n.d(c,l,function(t){return e[t]}.bind(null,l));return c},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=15)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _default; });\n/* harmony import */ var _libs_nanoevents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\nvar LOG = \'[ FxBase ]\';\nvar DEBUG = true;\n\nvar _default =\n/*#__PURE__*/\nfunction (_NanoEvents) {\n  _inherits(_default, _NanoEvents);\n\n  function _default(element, options) {\n    var _this;\n\n    _classCallCheck(this, _default);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_default).call(this));\n    _this.manifest = _this.constructor.manifest;\n    _this.type = _this.manifest.id;\n    _this.element = element;\n    _this.options = options || {};\n    return _this;\n  }\n\n  _createClass(_default, [{\n    key: "init",\n    value: function init() {\n      this.options = Object.assign({}, this.manifest.options, this.options);\n      this.init();\n    }\n  }, {\n    key: "update",\n    value: function update() {}\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(_libs_nanoevents__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9oZXJvL2Z4L0Z4QmFzZS5qcz82YmNhIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5pbXBvcnQgTmFub0V2ZW50cyBmcm9tICcuLi8uLi8uLi9saWJzL25hbm9ldmVudHMnO1xudmFyIExPRyA9ICdbIEZ4QmFzZSBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX05hbm9FdmVudHMpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfTmFub0V2ZW50cyk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuY2FsbCh0aGlzKSk7XG4gICAgX3RoaXMubWFuaWZlc3QgPSBfdGhpcy5jb25zdHJ1Y3Rvci5tYW5pZmVzdDtcbiAgICBfdGhpcy50eXBlID0gX3RoaXMubWFuaWZlc3QuaWQ7XG4gICAgX3RoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm1hbmlmZXN0Lm9wdGlvbnMsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShOYW5vRXZlbnRzKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  SCENE_PLUGINS_READY: 'SCENE_PLUGINS_READY',\n  SCENE_PRE_READY: 'SCENE_PRE_READY',\n  SCENE_READY: 'SCENE_READY'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9mdXNpb24vQ29uc3QuanM/YTE5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7XG4gIFNDRU5FX1BMVUdJTlNfUkVBRFk6ICdTQ0VORV9QTFVHSU5TX1JFQURZJyxcbiAgU0NFTkVfUFJFX1JFQURZOiAnU0NFTkVfUFJFX1JFQURZJyxcbiAgU0NFTkVfUkVBRFk6ICdTQ0VORV9SRUFEWSdcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _default; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Nano Events\n * Taken from https://github.com/ai/nanoevents (MIT license)\n */\nvar _default =\n/*#__PURE__*/\nfunction () {\n  function _default() {\n    _classCallCheck(this, _default);\n\n    _defineProperty(this, "events", {});\n  }\n  /**\n   * Calls each of the listeners registered for a given event.\n   *\n   * @param {string} event The event name.\n   * @param {...*} arguments The arguments for listeners.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * ee.emit(\'tick\', tickType, tickDuration)\n   *\n   * @alias NanoEvents#emit\n   * @method\n   */\n\n\n  _createClass(_default, [{\n    key: "emit",\n    value: function emit(event) {\n      var args = [].slice.call(arguments, 1) // Array.prototype.call() returns empty array if context is not array-like\n      ;\n      [].slice.call(this.events[event] || []).filter(function (i) {\n        i.apply(null, args);\n      });\n    }\n    /**\n     * Add a listener for a given event.\n     *\n     * @param {string} event The event name.\n     * @param {function} cb The listener function.\n     *\n     * @return {function} Unbind listener from event.\n     *\n     * @example\n     * const unbind = ee.on(\'tick\', (tickType, tickDuration) => {\n     *   count += 1\n     * })\n     *\n     * disable () {\n     *   unbind()\n     * }\n     *\n     * @alias NanoEvents#on\n     * @method\n     */\n\n  }, {\n    key: "on",\n    value: function on(event, cb) {\n      if (false) {}\n\n      (this.events[event] = this.events[event] || []).push(cb);\n      return function () {\n        this.events[event] = this.events[event].filter(function (i) {\n          return i !== cb;\n        });\n      }.bind(this);\n    }\n    /**\n     * Removes all listeners.\n     *\n     * @returns {undefined}\n     *\n     * @example\n     * unbindAll(emitter)\n     */\n\n  }, {\n    key: "unbindAll",\n    value: function unbindAll() {\n      this.events = {};\n    }\n  }]);\n\n  return _default;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYnMvbmFub2V2ZW50cy5qcz9kYTNiIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4gKiBOYW5vIEV2ZW50c1xuICogVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWkvbmFub2V2ZW50cyAoTUlUIGxpY2Vuc2UpXG4gKi9cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudHNcIiwge30pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cyBUaGUgYXJndW1lbnRzIGZvciBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWUuZW1pdCgndGljaycsIHRpY2tUeXBlLCB0aWNrRHVyYXRpb24pXG4gICAqXG4gICAqIEBhbGlhcyBOYW5vRXZlbnRzI2VtaXRcbiAgICogQG1ldGhvZFxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiZW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSAvLyBBcnJheS5wcm90b3R5cGUuY2FsbCgpIHJldHVybnMgZW1wdHkgYXJyYXkgaWYgY29udGV4dCBpcyBub3QgYXJyYXktbGlrZVxuICAgICAgO1xuICAgICAgW10uc2xpY2UuY2FsbCh0aGlzLmV2ZW50c1tldmVudF0gfHwgW10pLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICBpLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBVbmJpbmQgbGlzdGVuZXIgZnJvbSBldmVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgdW5iaW5kID0gZWUub24oJ3RpY2snLCAodGlja1R5cGUsIHRpY2tEdXJhdGlvbikgPT4ge1xuICAgICAqICAgY291bnQgKz0gMVxuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBkaXNhYmxlICgpIHtcbiAgICAgKiAgIHVuYmluZCgpXG4gICAgICogfVxuICAgICAqXG4gICAgICogQGFsaWFzIE5hbm9FdmVudHMjb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgY2IpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgfVxuXG4gICAgICAodGhpcy5ldmVudHNbZXZlbnRdID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdKS5wdXNoKGNiKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50XSA9IHRoaXMuZXZlbnRzW2V2ZW50XS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaSAhPT0gY2I7XG4gICAgICAgIH0pO1xuICAgICAgfS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB1bmJpbmRBbGwoZW1pdHRlcilcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuYmluZEFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRBbGwoKSB7XG4gICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yZGJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], " {").concat(content, "}");\n      }\n\n      return content;\n    }).join(\'\');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \'string\') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \'\']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\'; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot || \'\').concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n  return "/*# ".concat(data, " */");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanM/MjRmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCAnJykuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n')},function(module){eval('module.exports = JSON.parse("{\\"name\\":\\"hero\\",\\"version\\":\\"1.0.0\\",\\"description\\":\\"\\",\\"private\\":true,\\"scripts\\":{\\"dev\\":\\"npx webpack --watch --devtool \'cheap-eval-source-map\'\\",\\"build\\":\\"npx webpack --mode \'production\'\\",\\"serve\\":\\"http-server -g -c-1\\"},\\"author\\":\\"Simon Widjaja\\",\\"devDependencies\\":{\\"@babel/cli\\":\\"^7.7.0\\",\\"@babel/core\\":\\"^7.7.2\\",\\"@babel/node\\":\\"^7.7.0\\",\\"@babel/plugin-proposal-class-properties\\":\\"^7.7.0\\",\\"@babel/preset-env\\":\\"^7.7.1\\",\\"@babel/register\\":\\"^7.7.0\\",\\"babel-register\\":\\"^6.26.0\\",\\"webpack\\":\\"^4.44.2\\",\\"webpack-cli\\":\\"^3.3.11\\",\\"webpack-dev-server\\":\\"^3.9.0\\"},\\"dependencies\\":{\\"@babel/plugin-transform-async-to-generator\\":\\"^7.7.0\\",\\"babel-loader\\":\\"^8.0.6\\",\\"core-js\\":\\"^3.4.0\\",\\"css-loader\\":\\"^3.6.0\\",\\"fs-extra\\":\\"^9.0.1\\",\\"lodash.debounce\\":\\"^4.0.8\\",\\"lodash.throttle\\":\\"^4.1.1\\",\\"node-sass\\":\\"^4.13.1\\",\\"regenerator-runtime\\":\\"^0.13.3\\",\\"sass-loader\\":\\"^8.0.0\\",\\"splitting\\":\\"^1.0.6\\",\\"style-loader\\":\\"^1.3.0\\"}}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){eval("(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\nvar root = document;\nvar createText = root.createTextNode.bind(root);\n\n/**\n * # setProperty\n * Apply a CSS var\n * @param el{HTMLElement} \n * @param varName {string} \n * @param value {string|number}  \n */\nfunction setProperty(el, varName, value) {\n    el.style.setProperty(varName, value);\n} \n\n/**\n * \n * @param {Node} el \n * @param {Node} child \n */\nfunction appendChild(el, child) {\n  return el.appendChild(child);\n}\n\nfunction createElement(parent, key, text, whitespace) {\n  var el = root.createElement('span');\n  key && (el.className = key); \n  if (text) { \n      !whitespace && el.setAttribute(\"data-\" + key, text);\n      el.textContent = text; \n  }\n  return (parent && appendChild(parent, el)) || el;\n}\n\nfunction getData(el, key) {\n  return el.getAttribute(\"data-\" + key)\n}\n\n/**\n * \n * @param e {import('../types').Target} \n * @param parent {HTMLElement}\n * @returns {HTMLElement[]}\n */\nfunction $(e, parent) {\n    return !e || e.length == 0\n        ? // null or empty string returns empty array\n          []\n        : e.nodeName\n            ? // a single element is wrapped in an array\n              [e]\n            : // selector and NodeList are converted to Element[]\n              [].slice.call(e[0].nodeName ? e : (parent || root).querySelectorAll(e));\n}\n\n/**\n * Creates and fills an array with the value provided\n * @template {T}\n * @param {number} len\n * @param {() => T} valueProvider\n * @return {T}\n */\nfunction Array2D(len) {\n    var a = [];\n    for (; len--; ) {\n        a[len] = [];\n    }\n    return a;\n}\n\nfunction each(items, fn) {\n    items && items.some(fn);\n}\n\nfunction selectFrom(obj) {\n    return function (key) {\n        return obj[key];\n    }\n}\n\n/**\n * # Splitting.index\n * Index split elements and add them to a Splitting instance.\n *\n * @param element {HTMLElement}\n * @param key {string}\n * @param items {HTMLElement[] | HTMLElement[][]}\n */\nfunction index(element, key, items) {\n    var prefix = '--' + key;\n    var cssVar = prefix + \"-index\";\n\n    each(items, function (items, i) {\n        if (Array.isArray(items)) {\n            each(items, function(item) {\n                setProperty(item, cssVar, i);\n            });\n        } else {\n            setProperty(items, cssVar, i);\n        }\n    });\n\n    setProperty(element, prefix + \"-total\", items.length);\n}\n\n/**\n * @type {Record<string, import('./types').ISplittingPlugin>}\n */\nvar plugins = {};\n\n/**\n * @param by {string}\n * @param parent {string}\n * @param deps {string[]}\n * @return {string[]}\n */\nfunction resolvePlugins(by, parent, deps) {\n    // skip if already visited this dependency\n    var index = deps.indexOf(by);\n    if (index == -1) {\n        // if new to dependency array, add to the beginning\n        deps.unshift(by);\n\n        // recursively call this function for all dependencies\n        each(plugins[by].depends, function(p) {\n            resolvePlugins(p, by, deps);\n        });\n    } else {\n        // if this dependency was added already move to the left of\n        // the parent dependency so it gets loaded in order\n        var indexOfParent = deps.indexOf(parent);\n        deps.splice(index, 1);\n        deps.splice(indexOfParent, 0, by);\n    }\n    return deps;\n}\n\n/**\n * Internal utility for creating plugins... essentially to reduce\n * the size of the library\n * @param {string} by \n * @param {string} key \n * @param {string[]} depends \n * @param {Function} split \n * @returns {import('./types').ISplittingPlugin}\n */\nfunction createPlugin(by, depends, key, split) {\n    return {\n        by: by,\n        depends: depends,\n        key: key,\n        split: split\n    }\n}\n\n/**\n *\n * @param by {string}\n * @returns {import('./types').ISplittingPlugin[]}\n */\nfunction resolve(by) {\n    return resolvePlugins(by, 0, []).map(selectFrom(plugins));\n}\n\n/**\n * Adds a new plugin to splitting\n * @param opts {import('./types').ISplittingPlugin}\n */\nfunction add(opts) {\n    plugins[opts.by] = opts;\n}\n\n/**\n * # Splitting.split\n * Split an element's textContent into individual elements\n * @param el {Node} Element to split\n * @param key {string}\n * @param splitOn {string}\n * @param includeSpace {boolean}\n * @returns {HTMLElement[]}\n */\nfunction splitText(el, key, splitOn, includePrevious, preserveWhitespace) {\n    // Combine any strange text nodes or empty whitespace.\n    el.normalize();\n\n    // Use fragment to prevent unnecessary DOM thrashing.\n    var elements = [];\n    var F = document.createDocumentFragment();\n\n    if (includePrevious) {\n        elements.push(el.previousSibling);\n    }\n\n    var allElements = [];\n    $(el.childNodes).some(function(next) {\n        if (next.tagName && !next.hasChildNodes()) {\n            // keep elements without child nodes (no text and no children)\n            allElements.push(next);\n            return;\n        }\n        // Recursively run through child nodes\n        if (next.childNodes && next.childNodes.length) {\n            allElements.push(next);\n            elements.push.apply(elements, splitText(next, key, splitOn, includePrevious, preserveWhitespace));\n            return;\n        }\n\n        // Get the text to split, trimming out the whitespace\n        /** @type {string} */\n        var wholeText = next.wholeText || '';\n        var contents = wholeText.trim();\n\n        // If there's no text left after trimming whitespace, continue the loop\n        if (contents.length) {\n            // insert leading space if there was one\n            if (wholeText[0] === ' ') {\n                allElements.push(createText(' '));\n            }\n            // Concatenate the split text children back into the full array\n            each(contents.split(splitOn), function(splitText, i) {\n                if (i && preserveWhitespace) {\n                    allElements.push(createElement(F, \"whitespace\", \" \", preserveWhitespace));\n                }\n                var splitEl = createElement(F, key, splitText);\n                elements.push(splitEl);\n                allElements.push(splitEl);\n            }); \n            // insert trailing space if there was one\n            if (wholeText[wholeText.length - 1] === ' ') {\n                allElements.push(createText(' '));\n            }\n        }\n    });\n\n    each(allElements, function(el) {\n        appendChild(F, el);\n    });\n\n    // Clear out the existing element\n    el.innerHTML = \"\";\n    appendChild(el, F);\n    return elements;\n}\n\n/** an empty value */\nvar _ = 0;\n\nfunction copy(dest, src) {\n    for (var k in src) {\n        dest[k] = src[k];\n    }\n    return dest;\n}\n\nvar WORDS = 'words';\n\nvar wordPlugin = createPlugin(\n    /*by: */ WORDS,\n    /*depends: */ _,\n    /*key: */ 'word', \n    /*split: */ function(el) {\n        return splitText(el, 'word', /\\s+/, 0, 1)\n    }\n);\n\nvar CHARS = \"chars\";\n\nvar charPlugin = createPlugin(\n    /*by: */ CHARS,\n    /*depends: */ [WORDS],\n    /*key: */ \"char\", \n    /*split: */ function(el, options, ctx) {\n        var results = [];\n\n        each(ctx[WORDS], function(word, i) {\n            results.push.apply(results, splitText(word, \"char\", \"\", options.whitespace && i));\n        });\n\n        return results;\n    }\n);\n\n/**\n * # Splitting\n * \n * @param opts {import('./types').ISplittingOptions} \n */\nfunction Splitting (opts) {\n  opts = opts || {};\n  var key = opts.key;\n\n  return $(opts.target || '[data-splitting]').map(function(el) {\n    var ctx = el[''];  \n    if (!opts.force && ctx) {\n      return ctx;\n    }\n\n    ctx = el[''] = { el: el };\n    var items = resolve(opts.by || getData(el, 'splitting') || CHARS);\n    var opts2 = copy({}, opts);\n    each(items, function(plugin) {\n      if (plugin.split) {\n        var pluginBy = plugin.by;\n        var key2 = (key ? '-' + key : '') + plugin.key;\n        var results = plugin.split(el, opts2, ctx);\n        key2 && index(el, key2, results);\n        ctx[pluginBy] = results;\n        el.classList.add(pluginBy);\n      } \n    });\n\n    el.classList.add('splitting');\n    return ctx;\n  })\n}\n\n/**\n * # Splitting.html\n * \n * @param opts {import('./types').ISplittingOptions}\n */\nfunction html(opts) {\n  opts = opts || {};\n  var parent = opts.target =  createElement();\n  parent.innerHTML = opts.content;\n  Splitting(opts);\n  return parent.outerHTML\n}\n\nSplitting.html = html;\nSplitting.add = add;\n\nfunction detectGrid(el, options, side) {\n    var items = $(options.matching || el.children, el);\n    var c = {};\n\n    each(items, function(w) {\n        var val = Math.round(w[side]);\n        (c[val] || (c[val] = [])).push(w);\n    });\n\n    return Object.keys(c).map(Number).sort(byNumber).map(selectFrom(c));\n}\n\nfunction byNumber(a, b) {\n    return a - b;\n}\n\nvar linePlugin = createPlugin(\n    /*by: */ 'lines',\n    /*depends: */ [WORDS],\n    /*key: */ 'line',\n    /*split: */ function(el, options, ctx) {\n      return detectGrid(el, { matching: ctx[WORDS] }, 'offsetTop')\n    }\n);\n\nvar itemPlugin = createPlugin(\n    /*by: */ 'items',\n    /*depends: */ _,\n    /*key: */ 'item', \n    /*split: */ function(el, options) {\n        return $(options.matching || el.children, el)\n    }\n);\n\nvar rowPlugin = createPlugin(\n    /*by: */ 'rows',\n    /*depends: */ _,\n    /*key: */ 'row', \n    /*split: */ function(el, options) {\n        return detectGrid(el, options, \"offsetTop\");\n    }\n);\n\nvar columnPlugin = createPlugin(\n    /*by: */ 'cols',\n    /*depends: */ _,\n    /*key: */ \"col\", \n    /*split: */ function(el, options) {\n        return detectGrid(el, options, \"offsetLeft\");\n    }\n);\n\nvar gridPlugin = createPlugin(\n    /*by: */ 'grid',\n    /*depends: */ ['rows', 'cols']\n);\n\nvar LAYOUT = \"layout\";\n\nvar layoutPlugin = createPlugin(\n    /*by: */ LAYOUT,\n    /*depends: */ _,\n    /*key: */ _,\n    /*split: */ function(el, opts) {\n        // detect and set options\n        var rows =  opts.rows = +(opts.rows || getData(el, 'rows') || 1);\n        var columns = opts.columns = +(opts.columns || getData(el, 'columns') || 1);\n\n        // Seek out the first <img> if the value is true \n        opts.image = opts.image || getData(el, 'image') || el.currentSrc || el.src;\n        if (opts.image) {\n            var img = $(\"img\", el)[0];\n            opts.image = img && (img.currentSrc || img.src);\n        }\n\n        // add optional image to background\n        if (opts.image) {\n            setProperty(el, \"background-image\", \"url(\" + opts.image + \")\");\n        }\n\n        var totalCells = rows * columns;\n        var elements = [];\n\n        var container = createElement(_, \"cell-grid\");\n        while (totalCells--) {\n            // Create a span\n            var cell = createElement(container, \"cell\");\n            createElement(cell, \"cell-inner\");\n            elements.push(cell);\n        }\n\n        // Append elements back into the parent\n        appendChild(el, container);\n\n        return elements;\n    }\n);\n\nvar cellRowPlugin = createPlugin(\n    /*by: */ \"cellRows\",\n    /*depends: */ [LAYOUT],\n    /*key: */ \"row\",\n    /*split: */ function(el, opts, ctx) {\n        var rowCount = opts.rows;\n        var result = Array2D(rowCount);\n\n        each(ctx[LAYOUT], function(cell, i, src) {\n            result[Math.floor(i / (src.length / rowCount))].push(cell);\n        });\n\n        return result;\n    }\n);\n\nvar cellColumnPlugin = createPlugin(\n    /*by: */ \"cellColumns\",\n    /*depends: */ [LAYOUT],\n    /*key: */ \"col\",\n    /*split: */ function(el, opts, ctx) {\n        var columnCount = opts.columns;\n        var result = Array2D(columnCount);\n\n        each(ctx[LAYOUT], function(cell, i) {\n            result[i % columnCount].push(cell);\n        });\n\n        return result;\n    }\n);\n\nvar cellPlugin = createPlugin(\n    /*by: */ \"cells\",\n    /*depends: */ ['cellRows', 'cellColumns'],\n    /*key: */ \"cell\", \n    /*split: */ function(el, opt, ctx) { \n        // re-index the layout as the cells\n        return ctx[LAYOUT];\n    }\n);\n\n// install plugins\n// word/char plugins\nadd(wordPlugin);\nadd(charPlugin);\nadd(linePlugin);\n// grid plugins\nadd(itemPlugin);\nadd(rowPlugin);\nadd(columnPlugin);\nadd(gridPlugin);\n// cell-layout plugins\nadd(layoutPlugin);\nadd(cellRowPlugin);\nadd(cellColumnPlugin);\nadd(cellPlugin);\n\nreturn Splitting;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcGxpdHRpbmcvZGlzdC9zcGxpdHRpbmcuanM/MWIxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuU3BsaXR0aW5nID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgcm9vdCA9IGRvY3VtZW50O1xudmFyIGNyZWF0ZVRleHQgPSByb290LmNyZWF0ZVRleHROb2RlLmJpbmQocm9vdCk7XG5cbi8qKlxuICogIyBzZXRQcm9wZXJ0eVxuICogQXBwbHkgYSBDU1MgdmFyXG4gKiBAcGFyYW0gZWx7SFRNTEVsZW1lbnR9IFxuICogQHBhcmFtIHZhck5hbWUge3N0cmluZ30gXG4gKiBAcGFyYW0gdmFsdWUge3N0cmluZ3xudW1iZXJ9ICBcbiAqL1xuZnVuY3Rpb24gc2V0UHJvcGVydHkoZWwsIHZhck5hbWUsIHZhbHVlKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkodmFyTmFtZSwgdmFsdWUpO1xufSBcblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7Tm9kZX0gZWwgXG4gKiBAcGFyYW0ge05vZGV9IGNoaWxkIFxuICovXG5mdW5jdGlvbiBhcHBlbmRDaGlsZChlbCwgY2hpbGQpIHtcbiAgcmV0dXJuIGVsLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudChwYXJlbnQsIGtleSwgdGV4dCwgd2hpdGVzcGFjZSkge1xuICB2YXIgZWwgPSByb290LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAga2V5ICYmIChlbC5jbGFzc05hbWUgPSBrZXkpOyBcbiAgaWYgKHRleHQpIHsgXG4gICAgICAhd2hpdGVzcGFjZSAmJiBlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiICsga2V5LCB0ZXh0KTtcbiAgICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDsgXG4gIH1cbiAgcmV0dXJuIChwYXJlbnQgJiYgYXBwZW5kQ2hpbGQocGFyZW50LCBlbCkpIHx8IGVsO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhKGVsLCBrZXkpIHtcbiAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcImRhdGEtXCIgKyBrZXkpXG59XG5cbi8qKlxuICogXG4gKiBAcGFyYW0gZSB7aW1wb3J0KCcuLi90eXBlcycpLlRhcmdldH0gXG4gKiBAcGFyYW0gcGFyZW50IHtIVE1MRWxlbWVudH1cbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFtdfVxuICovXG5mdW5jdGlvbiAkKGUsIHBhcmVudCkge1xuICAgIHJldHVybiAhZSB8fCBlLmxlbmd0aCA9PSAwXG4gICAgICAgID8gLy8gbnVsbCBvciBlbXB0eSBzdHJpbmcgcmV0dXJucyBlbXB0eSBhcnJheVxuICAgICAgICAgIFtdXG4gICAgICAgIDogZS5ub2RlTmFtZVxuICAgICAgICAgICAgPyAvLyBhIHNpbmdsZSBlbGVtZW50IGlzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAgICAgICAgICAgW2VdXG4gICAgICAgICAgICA6IC8vIHNlbGVjdG9yIGFuZCBOb2RlTGlzdCBhcmUgY29udmVydGVkIHRvIEVsZW1lbnRbXVxuICAgICAgICAgICAgICBbXS5zbGljZS5jYWxsKGVbMF0ubm9kZU5hbWUgPyBlIDogKHBhcmVudCB8fCByb290KS5xdWVyeVNlbGVjdG9yQWxsKGUpKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCBmaWxscyBhbiBhcnJheSB3aXRoIHRoZSB2YWx1ZSBwcm92aWRlZFxuICogQHRlbXBsYXRlIHtUfVxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICogQHBhcmFtIHsoKSA9PiBUfSB2YWx1ZVByb3ZpZGVyXG4gKiBAcmV0dXJuIHtUfVxuICovXG5mdW5jdGlvbiBBcnJheTJEKGxlbikge1xuICAgIHZhciBhID0gW107XG4gICAgZm9yICg7IGxlbi0tOyApIHtcbiAgICAgICAgYVtsZW5dID0gW107XG4gICAgfVxuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBlYWNoKGl0ZW1zLCBmbikge1xuICAgIGl0ZW1zICYmIGl0ZW1zLnNvbWUoZm4pO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RGcm9tKG9iaikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9XG59XG5cbi8qKlxuICogIyBTcGxpdHRpbmcuaW5kZXhcbiAqIEluZGV4IHNwbGl0IGVsZW1lbnRzIGFuZCBhZGQgdGhlbSB0byBhIFNwbGl0dGluZyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gZWxlbWVudCB7SFRNTEVsZW1lbnR9XG4gKiBAcGFyYW0ga2V5IHtzdHJpbmd9XG4gKiBAcGFyYW0gaXRlbXMge0hUTUxFbGVtZW50W10gfCBIVE1MRWxlbWVudFtdW119XG4gKi9cbmZ1bmN0aW9uIGluZGV4KGVsZW1lbnQsIGtleSwgaXRlbXMpIHtcbiAgICB2YXIgcHJlZml4ID0gJy0tJyArIGtleTtcbiAgICB2YXIgY3NzVmFyID0gcHJlZml4ICsgXCItaW5kZXhcIjtcblxuICAgIGVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtcywgaSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgIGVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBzZXRQcm9wZXJ0eShpdGVtLCBjc3NWYXIsIGkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRQcm9wZXJ0eShpdGVtcywgY3NzVmFyLCBpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgc2V0UHJvcGVydHkoZWxlbWVudCwgcHJlZml4ICsgXCItdG90YWxcIiwgaXRlbXMubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgaW1wb3J0KCcuL3R5cGVzJykuSVNwbGl0dGluZ1BsdWdpbj59XG4gKi9cbnZhciBwbHVnaW5zID0ge307XG5cbi8qKlxuICogQHBhcmFtIGJ5IHtzdHJpbmd9XG4gKiBAcGFyYW0gcGFyZW50IHtzdHJpbmd9XG4gKiBAcGFyYW0gZGVwcyB7c3RyaW5nW119XG4gKiBAcmV0dXJuIHtzdHJpbmdbXX1cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVBsdWdpbnMoYnksIHBhcmVudCwgZGVwcykge1xuICAgIC8vIHNraXAgaWYgYWxyZWFkeSB2aXNpdGVkIHRoaXMgZGVwZW5kZW5jeVxuICAgIHZhciBpbmRleCA9IGRlcHMuaW5kZXhPZihieSk7XG4gICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICAgIC8vIGlmIG5ldyB0byBkZXBlbmRlbmN5IGFycmF5LCBhZGQgdG8gdGhlIGJlZ2lubmluZ1xuICAgICAgICBkZXBzLnVuc2hpZnQoYnkpO1xuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNhbGwgdGhpcyBmdW5jdGlvbiBmb3IgYWxsIGRlcGVuZGVuY2llc1xuICAgICAgICBlYWNoKHBsdWdpbnNbYnldLmRlcGVuZHMsIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJlc29sdmVQbHVnaW5zKHAsIGJ5LCBkZXBzKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgdGhpcyBkZXBlbmRlbmN5IHdhcyBhZGRlZCBhbHJlYWR5IG1vdmUgdG8gdGhlIGxlZnQgb2ZcbiAgICAgICAgLy8gdGhlIHBhcmVudCBkZXBlbmRlbmN5IHNvIGl0IGdldHMgbG9hZGVkIGluIG9yZGVyXG4gICAgICAgIHZhciBpbmRleE9mUGFyZW50ID0gZGVwcy5pbmRleE9mKHBhcmVudCk7XG4gICAgICAgIGRlcHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgZGVwcy5zcGxpY2UoaW5kZXhPZlBhcmVudCwgMCwgYnkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwcztcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCB1dGlsaXR5IGZvciBjcmVhdGluZyBwbHVnaW5zLi4uIGVzc2VudGlhbGx5IHRvIHJlZHVjZVxuICogdGhlIHNpemUgb2YgdGhlIGxpYnJhcnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBieSBcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBkZXBlbmRzIFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3BsaXQgXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3R5cGVzJykuSVNwbGl0dGluZ1BsdWdpbn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGx1Z2luKGJ5LCBkZXBlbmRzLCBrZXksIHNwbGl0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYnk6IGJ5LFxuICAgICAgICBkZXBlbmRzOiBkZXBlbmRzLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgc3BsaXQ6IHNwbGl0XG4gICAgfVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gYnkge3N0cmluZ31cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vdHlwZXMnKS5JU3BsaXR0aW5nUGx1Z2luW119XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUoYnkpIHtcbiAgICByZXR1cm4gcmVzb2x2ZVBsdWdpbnMoYnksIDAsIFtdKS5tYXAoc2VsZWN0RnJvbShwbHVnaW5zKSk7XG59XG5cbi8qKlxuICogQWRkcyBhIG5ldyBwbHVnaW4gdG8gc3BsaXR0aW5nXG4gKiBAcGFyYW0gb3B0cyB7aW1wb3J0KCcuL3R5cGVzJykuSVNwbGl0dGluZ1BsdWdpbn1cbiAqL1xuZnVuY3Rpb24gYWRkKG9wdHMpIHtcbiAgICBwbHVnaW5zW29wdHMuYnldID0gb3B0cztcbn1cblxuLyoqXG4gKiAjIFNwbGl0dGluZy5zcGxpdFxuICogU3BsaXQgYW4gZWxlbWVudCdzIHRleHRDb250ZW50IGludG8gaW5kaXZpZHVhbCBlbGVtZW50c1xuICogQHBhcmFtIGVsIHtOb2RlfSBFbGVtZW50IHRvIHNwbGl0XG4gKiBAcGFyYW0ga2V5IHtzdHJpbmd9XG4gKiBAcGFyYW0gc3BsaXRPbiB7c3RyaW5nfVxuICogQHBhcmFtIGluY2x1ZGVTcGFjZSB7Ym9vbGVhbn1cbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFtdfVxuICovXG5mdW5jdGlvbiBzcGxpdFRleHQoZWwsIGtleSwgc3BsaXRPbiwgaW5jbHVkZVByZXZpb3VzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UpIHtcbiAgICAvLyBDb21iaW5lIGFueSBzdHJhbmdlIHRleHQgbm9kZXMgb3IgZW1wdHkgd2hpdGVzcGFjZS5cbiAgICBlbC5ub3JtYWxpemUoKTtcblxuICAgIC8vIFVzZSBmcmFnbWVudCB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTSB0aHJhc2hpbmcuXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIEYgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBpZiAoaW5jbHVkZVByZXZpb3VzKSB7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWwucHJldmlvdXNTaWJsaW5nKTtcbiAgICB9XG5cbiAgICB2YXIgYWxsRWxlbWVudHMgPSBbXTtcbiAgICAkKGVsLmNoaWxkTm9kZXMpLnNvbWUoZnVuY3Rpb24obmV4dCkge1xuICAgICAgICBpZiAobmV4dC50YWdOYW1lICYmICFuZXh0Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgLy8ga2VlcCBlbGVtZW50cyB3aXRob3V0IGNoaWxkIG5vZGVzIChubyB0ZXh0IGFuZCBubyBjaGlsZHJlbilcbiAgICAgICAgICAgIGFsbEVsZW1lbnRzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgcnVuIHRocm91Z2ggY2hpbGQgbm9kZXNcbiAgICAgICAgaWYgKG5leHQuY2hpbGROb2RlcyAmJiBuZXh0LmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhbGxFbGVtZW50cy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaC5hcHBseShlbGVtZW50cywgc3BsaXRUZXh0KG5leHQsIGtleSwgc3BsaXRPbiwgaW5jbHVkZVByZXZpb3VzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB0aGUgdGV4dCB0byBzcGxpdCwgdHJpbW1pbmcgb3V0IHRoZSB3aGl0ZXNwYWNlXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB2YXIgd2hvbGVUZXh0ID0gbmV4dC53aG9sZVRleHQgfHwgJyc7XG4gICAgICAgIHZhciBjb250ZW50cyA9IHdob2xlVGV4dC50cmltKCk7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyB0ZXh0IGxlZnQgYWZ0ZXIgdHJpbW1pbmcgd2hpdGVzcGFjZSwgY29udGludWUgdGhlIGxvb3BcbiAgICAgICAgaWYgKGNvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGxlYWRpbmcgc3BhY2UgaWYgdGhlcmUgd2FzIG9uZVxuICAgICAgICAgICAgaWYgKHdob2xlVGV4dFswXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgYWxsRWxlbWVudHMucHVzaChjcmVhdGVUZXh0KCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29uY2F0ZW5hdGUgdGhlIHNwbGl0IHRleHQgY2hpbGRyZW4gYmFjayBpbnRvIHRoZSBmdWxsIGFycmF5XG4gICAgICAgICAgICBlYWNoKGNvbnRlbnRzLnNwbGl0KHNwbGl0T24pLCBmdW5jdGlvbihzcGxpdFRleHQsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAmJiBwcmVzZXJ2ZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsRWxlbWVudHMucHVzaChjcmVhdGVFbGVtZW50KEYsIFwid2hpdGVzcGFjZVwiLCBcIiBcIiwgcHJlc2VydmVXaGl0ZXNwYWNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzcGxpdEVsID0gY3JlYXRlRWxlbWVudChGLCBrZXksIHNwbGl0VGV4dCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChzcGxpdEVsKTtcbiAgICAgICAgICAgICAgICBhbGxFbGVtZW50cy5wdXNoKHNwbGl0RWwpO1xuICAgICAgICAgICAgfSk7IFxuICAgICAgICAgICAgLy8gaW5zZXJ0IHRyYWlsaW5nIHNwYWNlIGlmIHRoZXJlIHdhcyBvbmVcbiAgICAgICAgICAgIGlmICh3aG9sZVRleHRbd2hvbGVUZXh0Lmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBhbGxFbGVtZW50cy5wdXNoKGNyZWF0ZVRleHQoJyAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGVhY2goYWxsRWxlbWVudHMsIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGFwcGVuZENoaWxkKEYsIGVsKTtcbiAgICB9KTtcblxuICAgIC8vIENsZWFyIG91dCB0aGUgZXhpc3RpbmcgZWxlbWVudFxuICAgIGVsLmlubmVySFRNTCA9IFwiXCI7XG4gICAgYXBwZW5kQ2hpbGQoZWwsIEYpO1xuICAgIHJldHVybiBlbGVtZW50cztcbn1cblxuLyoqIGFuIGVtcHR5IHZhbHVlICovXG52YXIgXyA9IDA7XG5cbmZ1bmN0aW9uIGNvcHkoZGVzdCwgc3JjKSB7XG4gICAgZm9yICh2YXIgayBpbiBzcmMpIHtcbiAgICAgICAgZGVzdFtrXSA9IHNyY1trXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5cbnZhciBXT1JEUyA9ICd3b3Jkcyc7XG5cbnZhciB3b3JkUGx1Z2luID0gY3JlYXRlUGx1Z2luKFxuICAgIC8qYnk6ICovIFdPUkRTLFxuICAgIC8qZGVwZW5kczogKi8gXyxcbiAgICAvKmtleTogKi8gJ3dvcmQnLCBcbiAgICAvKnNwbGl0OiAqLyBmdW5jdGlvbihlbCkge1xuICAgICAgICByZXR1cm4gc3BsaXRUZXh0KGVsLCAnd29yZCcsIC9cXHMrLywgMCwgMSlcbiAgICB9XG4pO1xuXG52YXIgQ0hBUlMgPSBcImNoYXJzXCI7XG5cbnZhciBjaGFyUGx1Z2luID0gY3JlYXRlUGx1Z2luKFxuICAgIC8qYnk6ICovIENIQVJTLFxuICAgIC8qZGVwZW5kczogKi8gW1dPUkRTXSxcbiAgICAvKmtleTogKi8gXCJjaGFyXCIsIFxuICAgIC8qc3BsaXQ6ICovIGZ1bmN0aW9uKGVsLCBvcHRpb25zLCBjdHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBlYWNoKGN0eFtXT1JEU10sIGZ1bmN0aW9uKHdvcmQsIGkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaC5hcHBseShyZXN1bHRzLCBzcGxpdFRleHQod29yZCwgXCJjaGFyXCIsIFwiXCIsIG9wdGlvbnMud2hpdGVzcGFjZSAmJiBpKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbik7XG5cbi8qKlxuICogIyBTcGxpdHRpbmdcbiAqIFxuICogQHBhcmFtIG9wdHMge2ltcG9ydCgnLi90eXBlcycpLklTcGxpdHRpbmdPcHRpb25zfSBcbiAqL1xuZnVuY3Rpb24gU3BsaXR0aW5nIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIga2V5ID0gb3B0cy5rZXk7XG5cbiAgcmV0dXJuICQob3B0cy50YXJnZXQgfHwgJ1tkYXRhLXNwbGl0dGluZ10nKS5tYXAoZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgY3R4ID0gZWxbJ/CfjYwnXTsgIFxuICAgIGlmICghb3B0cy5mb3JjZSAmJiBjdHgpIHtcbiAgICAgIHJldHVybiBjdHg7XG4gICAgfVxuXG4gICAgY3R4ID0gZWxbJ/CfjYwnXSA9IHsgZWw6IGVsIH07XG4gICAgdmFyIGl0ZW1zID0gcmVzb2x2ZShvcHRzLmJ5IHx8IGdldERhdGEoZWwsICdzcGxpdHRpbmcnKSB8fCBDSEFSUyk7XG4gICAgdmFyIG9wdHMyID0gY29weSh7fSwgb3B0cyk7XG4gICAgZWFjaChpdGVtcywgZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICBpZiAocGx1Z2luLnNwbGl0KSB7XG4gICAgICAgIHZhciBwbHVnaW5CeSA9IHBsdWdpbi5ieTtcbiAgICAgICAgdmFyIGtleTIgPSAoa2V5ID8gJy0nICsga2V5IDogJycpICsgcGx1Z2luLmtleTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBwbHVnaW4uc3BsaXQoZWwsIG9wdHMyLCBjdHgpO1xuICAgICAgICBrZXkyICYmIGluZGV4KGVsLCBrZXkyLCByZXN1bHRzKTtcbiAgICAgICAgY3R4W3BsdWdpbkJ5XSA9IHJlc3VsdHM7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQocGx1Z2luQnkpO1xuICAgICAgfSBcbiAgICB9KTtcblxuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ3NwbGl0dGluZycpO1xuICAgIHJldHVybiBjdHg7XG4gIH0pXG59XG5cbi8qKlxuICogIyBTcGxpdHRpbmcuaHRtbFxuICogXG4gKiBAcGFyYW0gb3B0cyB7aW1wb3J0KCcuL3R5cGVzJykuSVNwbGl0dGluZ09wdGlvbnN9XG4gKi9cbmZ1bmN0aW9uIGh0bWwob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIHBhcmVudCA9IG9wdHMudGFyZ2V0ID0gIGNyZWF0ZUVsZW1lbnQoKTtcbiAgcGFyZW50LmlubmVySFRNTCA9IG9wdHMuY29udGVudDtcbiAgU3BsaXR0aW5nKG9wdHMpO1xuICByZXR1cm4gcGFyZW50Lm91dGVySFRNTFxufVxuXG5TcGxpdHRpbmcuaHRtbCA9IGh0bWw7XG5TcGxpdHRpbmcuYWRkID0gYWRkO1xuXG5mdW5jdGlvbiBkZXRlY3RHcmlkKGVsLCBvcHRpb25zLCBzaWRlKSB7XG4gICAgdmFyIGl0ZW1zID0gJChvcHRpb25zLm1hdGNoaW5nIHx8IGVsLmNoaWxkcmVuLCBlbCk7XG4gICAgdmFyIGMgPSB7fTtcblxuICAgIGVhY2goaXRlbXMsIGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgdmFyIHZhbCA9IE1hdGgucm91bmQod1tzaWRlXSk7XG4gICAgICAgIChjW3ZhbF0gfHwgKGNbdmFsXSA9IFtdKSkucHVzaCh3KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhjKS5tYXAoTnVtYmVyKS5zb3J0KGJ5TnVtYmVyKS5tYXAoc2VsZWN0RnJvbShjKSk7XG59XG5cbmZ1bmN0aW9uIGJ5TnVtYmVyKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG59XG5cbnZhciBsaW5lUGx1Z2luID0gY3JlYXRlUGx1Z2luKFxuICAgIC8qYnk6ICovICdsaW5lcycsXG4gICAgLypkZXBlbmRzOiAqLyBbV09SRFNdLFxuICAgIC8qa2V5OiAqLyAnbGluZScsXG4gICAgLypzcGxpdDogKi8gZnVuY3Rpb24oZWwsIG9wdGlvbnMsIGN0eCkge1xuICAgICAgcmV0dXJuIGRldGVjdEdyaWQoZWwsIHsgbWF0Y2hpbmc6IGN0eFtXT1JEU10gfSwgJ29mZnNldFRvcCcpXG4gICAgfVxuKTtcblxudmFyIGl0ZW1QbHVnaW4gPSBjcmVhdGVQbHVnaW4oXG4gICAgLypieTogKi8gJ2l0ZW1zJyxcbiAgICAvKmRlcGVuZHM6ICovIF8sXG4gICAgLyprZXk6ICovICdpdGVtJywgXG4gICAgLypzcGxpdDogKi8gZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICQob3B0aW9ucy5tYXRjaGluZyB8fCBlbC5jaGlsZHJlbiwgZWwpXG4gICAgfVxuKTtcblxudmFyIHJvd1BsdWdpbiA9IGNyZWF0ZVBsdWdpbihcbiAgICAvKmJ5OiAqLyAncm93cycsXG4gICAgLypkZXBlbmRzOiAqLyBfLFxuICAgIC8qa2V5OiAqLyAncm93JywgXG4gICAgLypzcGxpdDogKi8gZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGRldGVjdEdyaWQoZWwsIG9wdGlvbnMsIFwib2Zmc2V0VG9wXCIpO1xuICAgIH1cbik7XG5cbnZhciBjb2x1bW5QbHVnaW4gPSBjcmVhdGVQbHVnaW4oXG4gICAgLypieTogKi8gJ2NvbHMnLFxuICAgIC8qZGVwZW5kczogKi8gXyxcbiAgICAvKmtleTogKi8gXCJjb2xcIiwgXG4gICAgLypzcGxpdDogKi8gZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGRldGVjdEdyaWQoZWwsIG9wdGlvbnMsIFwib2Zmc2V0TGVmdFwiKTtcbiAgICB9XG4pO1xuXG52YXIgZ3JpZFBsdWdpbiA9IGNyZWF0ZVBsdWdpbihcbiAgICAvKmJ5OiAqLyAnZ3JpZCcsXG4gICAgLypkZXBlbmRzOiAqLyBbJ3Jvd3MnLCAnY29scyddXG4pO1xuXG52YXIgTEFZT1VUID0gXCJsYXlvdXRcIjtcblxudmFyIGxheW91dFBsdWdpbiA9IGNyZWF0ZVBsdWdpbihcbiAgICAvKmJ5OiAqLyBMQVlPVVQsXG4gICAgLypkZXBlbmRzOiAqLyBfLFxuICAgIC8qa2V5OiAqLyBfLFxuICAgIC8qc3BsaXQ6ICovIGZ1bmN0aW9uKGVsLCBvcHRzKSB7XG4gICAgICAgIC8vIGRldGVjdCBhbmQgc2V0IG9wdGlvbnNcbiAgICAgICAgdmFyIHJvd3MgPSAgb3B0cy5yb3dzID0gKyhvcHRzLnJvd3MgfHwgZ2V0RGF0YShlbCwgJ3Jvd3MnKSB8fCAxKTtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBvcHRzLmNvbHVtbnMgPSArKG9wdHMuY29sdW1ucyB8fCBnZXREYXRhKGVsLCAnY29sdW1ucycpIHx8IDEpO1xuXG4gICAgICAgIC8vIFNlZWsgb3V0IHRoZSBmaXJzdCA8aW1nPiBpZiB0aGUgdmFsdWUgaXMgdHJ1ZSBcbiAgICAgICAgb3B0cy5pbWFnZSA9IG9wdHMuaW1hZ2UgfHwgZ2V0RGF0YShlbCwgJ2ltYWdlJykgfHwgZWwuY3VycmVudFNyYyB8fCBlbC5zcmM7XG4gICAgICAgIGlmIChvcHRzLmltYWdlKSB7XG4gICAgICAgICAgICB2YXIgaW1nID0gJChcImltZ1wiLCBlbClbMF07XG4gICAgICAgICAgICBvcHRzLmltYWdlID0gaW1nICYmIChpbWcuY3VycmVudFNyYyB8fCBpbWcuc3JjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBvcHRpb25hbCBpbWFnZSB0byBiYWNrZ3JvdW5kXG4gICAgICAgIGlmIChvcHRzLmltYWdlKSB7XG4gICAgICAgICAgICBzZXRQcm9wZXJ0eShlbCwgXCJiYWNrZ3JvdW5kLWltYWdlXCIsIFwidXJsKFwiICsgb3B0cy5pbWFnZSArIFwiKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3RhbENlbGxzID0gcm93cyAqIGNvbHVtbnM7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXG4gICAgICAgIHZhciBjb250YWluZXIgPSBjcmVhdGVFbGVtZW50KF8sIFwiY2VsbC1ncmlkXCIpO1xuICAgICAgICB3aGlsZSAodG90YWxDZWxscy0tKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzcGFuXG4gICAgICAgICAgICB2YXIgY2VsbCA9IGNyZWF0ZUVsZW1lbnQoY29udGFpbmVyLCBcImNlbGxcIik7XG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KGNlbGwsIFwiY2VsbC1pbm5lclwiKTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goY2VsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBlbmQgZWxlbWVudHMgYmFjayBpbnRvIHRoZSBwYXJlbnRcbiAgICAgICAgYXBwZW5kQ2hpbGQoZWwsIGNvbnRhaW5lcik7XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cbik7XG5cbnZhciBjZWxsUm93UGx1Z2luID0gY3JlYXRlUGx1Z2luKFxuICAgIC8qYnk6ICovIFwiY2VsbFJvd3NcIixcbiAgICAvKmRlcGVuZHM6ICovIFtMQVlPVVRdLFxuICAgIC8qa2V5OiAqLyBcInJvd1wiLFxuICAgIC8qc3BsaXQ6ICovIGZ1bmN0aW9uKGVsLCBvcHRzLCBjdHgpIHtcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gb3B0cy5yb3dzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gQXJyYXkyRChyb3dDb3VudCk7XG5cbiAgICAgICAgZWFjaChjdHhbTEFZT1VUXSwgZnVuY3Rpb24oY2VsbCwgaSwgc3JjKSB7XG4gICAgICAgICAgICByZXN1bHRbTWF0aC5mbG9vcihpIC8gKHNyYy5sZW5ndGggLyByb3dDb3VudCkpXS5wdXNoKGNlbGwpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbik7XG5cbnZhciBjZWxsQ29sdW1uUGx1Z2luID0gY3JlYXRlUGx1Z2luKFxuICAgIC8qYnk6ICovIFwiY2VsbENvbHVtbnNcIixcbiAgICAvKmRlcGVuZHM6ICovIFtMQVlPVVRdLFxuICAgIC8qa2V5OiAqLyBcImNvbFwiLFxuICAgIC8qc3BsaXQ6ICovIGZ1bmN0aW9uKGVsLCBvcHRzLCBjdHgpIHtcbiAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gb3B0cy5jb2x1bW5zO1xuICAgICAgICB2YXIgcmVzdWx0ID0gQXJyYXkyRChjb2x1bW5Db3VudCk7XG5cbiAgICAgICAgZWFjaChjdHhbTEFZT1VUXSwgZnVuY3Rpb24oY2VsbCwgaSkge1xuICAgICAgICAgICAgcmVzdWx0W2kgJSBjb2x1bW5Db3VudF0ucHVzaChjZWxsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4pO1xuXG52YXIgY2VsbFBsdWdpbiA9IGNyZWF0ZVBsdWdpbihcbiAgICAvKmJ5OiAqLyBcImNlbGxzXCIsXG4gICAgLypkZXBlbmRzOiAqLyBbJ2NlbGxSb3dzJywgJ2NlbGxDb2x1bW5zJ10sXG4gICAgLyprZXk6ICovIFwiY2VsbFwiLCBcbiAgICAvKnNwbGl0OiAqLyBmdW5jdGlvbihlbCwgb3B0LCBjdHgpIHsgXG4gICAgICAgIC8vIHJlLWluZGV4IHRoZSBsYXlvdXQgYXMgdGhlIGNlbGxzXG4gICAgICAgIHJldHVybiBjdHhbTEFZT1VUXTtcbiAgICB9XG4pO1xuXG4vLyBpbnN0YWxsIHBsdWdpbnNcbi8vIHdvcmQvY2hhciBwbHVnaW5zXG5hZGQod29yZFBsdWdpbik7XG5hZGQoY2hhclBsdWdpbik7XG5hZGQobGluZVBsdWdpbik7XG4vLyBncmlkIHBsdWdpbnNcbmFkZChpdGVtUGx1Z2luKTtcbmFkZChyb3dQbHVnaW4pO1xuYWRkKGNvbHVtblBsdWdpbik7XG5hZGQoZ3JpZFBsdWdpbik7XG4vLyBjZWxsLWxheW91dCBwbHVnaW5zXG5hZGQobGF5b3V0UGx1Z2luKTtcbmFkZChjZWxsUm93UGx1Z2luKTtcbmFkZChjZWxsQ29sdW1uUGx1Z2luKTtcbmFkZChjZWxsUGx1Z2luKTtcblxucmV0dXJuIFNwbGl0dGluZztcblxufSkpKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLFVBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n")},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n')},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = throttle;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(7)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gudGhyb3R0bGUvaW5kZXguanM/ODRhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gKlxuICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(7)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanM/ZjdmZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _default; });\n/* harmony import */ var _FxBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// SCAN FOR FX\n\nvar LOG = \'[ FxScanner ]\';\nvar DEBUG = false;\n\nvar _default =\n/*#__PURE__*/\nfunction () {\n  function _default() {\n    _classCallCheck(this, _default);\n  }\n\n  _createClass(_default, null, [{\n    key: "scan",\n    value: function scan(context) {\n      if (context instanceof Element) {\n        this._scanElement(context);\n      }\n    }\n  }, {\n    key: "_scanElement",\n    value: function _scanElement(element) {\n      var _this = this;\n\n      Object.keys(hero.fx).forEach(function (item) {\n        if (hero.fx[item].prototype instanceof _FxBase__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]) {\n          _this._processFx(element, item);\n        }\n      });\n    }\n  }, {\n    key: "_processFx",\n    value: function _processFx(element, fx) {\n      var attr = "hero-fx-".concat(hero.fx[fx].manifest.id);\n      var elements = element.querySelectorAll("[".concat(attr, "]"));\n\n      for (var i = 0; i < elements.length; i++) {\n        var _element = elements[i];\n        if (_element.hero && _element.hero.scanned[fx]) continue;\n        var options = this.extractOptions(_element.getAttribute(attr));\n        var trigger = options.trigger || hero.fx[fx].manifest.options.trigger || \'click\';\n        DEBUG && console.log(LOG, \'_processFx()\', "fx: ".concat(fx));\n        hero.add(_element, trigger, hero.fx[fx], options);\n        hero.prepareElement(_element); // element.hero.scanned = true;\n\n        _element.hero.scanned[fx] = true;\n      }\n    }\n  }, {\n    key: "extractOptions",\n    value: function extractOptions(raw) {\n      if (!raw) return {}; // Eval solution\n\n      return eval("(function() { return ".concat(raw, "})()")); // Primitive version (only support flat non-nested values, no arrays , no objects)\n      // raw = raw.replace(/{(.*)}/, \'$1\');\n      // let args = raw.split(\',\').map( (item) => item.trim().split(\':\') );\n      // let result = {};\n      // args.forEach(item => { \n      //   let val = item[1].trim();\n      //   if (!isNaN(val)) { val = +val; }\n      //   else if (val.indexOf("\'") == 0) { val = val.replace(/\'/g, \'\'); }\n      //   else if (val == \'true\') { val = true; }\n      //   else if (val == \'false\') { val = false; }\n      //   result[item[0].trim()] = val; \n      // });\n      // return result;\n    }\n  }]);\n\n  return _default;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaGVyby9meC9GeFNjYW5uZXIuanM/MjJmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8vIFNDQU4gRk9SIEZYXG5pbXBvcnQgRnhCYXNlIGZyb20gJy4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGeFNjYW5uZXIgXSc7XG52YXIgREVCVUcgPSBmYWxzZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgbnVsbCwgW3tcbiAgICBrZXk6IFwic2NhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2FuKGNvbnRleHQpIHtcbiAgICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICB0aGlzLl9zY2FuRWxlbWVudChjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NjYW5FbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zY2FuRWxlbWVudChlbGVtZW50KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBPYmplY3Qua2V5cyhoZXJvLmZ4KS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChoZXJvLmZ4W2l0ZW1dLnByb3RvdHlwZSBpbnN0YW5jZW9mIEZ4QmFzZSkge1xuICAgICAgICAgIF90aGlzLl9wcm9jZXNzRngoZWxlbWVudCwgaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcHJvY2Vzc0Z4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcm9jZXNzRngoZWxlbWVudCwgZngpIHtcbiAgICAgIHZhciBhdHRyID0gXCJoZXJvLWZ4LVwiLmNvbmNhdChoZXJvLmZ4W2Z4XS5tYW5pZmVzdC5pZCk7XG4gICAgICB2YXIgZWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbXCIuY29uY2F0KGF0dHIsIFwiXVwiKSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9lbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgIGlmIChfZWxlbWVudC5oZXJvICYmIF9lbGVtZW50Lmhlcm8uc2Nhbm5lZFtmeF0pIGNvbnRpbnVlO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZXh0cmFjdE9wdGlvbnMoX2VsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHIpKTtcbiAgICAgICAgdmFyIHRyaWdnZXIgPSBvcHRpb25zLnRyaWdnZXIgfHwgaGVyby5meFtmeF0ubWFuaWZlc3Qub3B0aW9ucy50cmlnZ2VyIHx8ICdjbGljayc7XG4gICAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ19wcm9jZXNzRngoKScsIFwiZng6IFwiLmNvbmNhdChmeCkpO1xuICAgICAgICBoZXJvLmFkZChfZWxlbWVudCwgdHJpZ2dlciwgaGVyby5meFtmeF0sIG9wdGlvbnMpO1xuICAgICAgICBoZXJvLnByZXBhcmVFbGVtZW50KF9lbGVtZW50KTsgLy8gZWxlbWVudC5oZXJvLnNjYW5uZWQgPSB0cnVlO1xuXG4gICAgICAgIF9lbGVtZW50Lmhlcm8uc2Nhbm5lZFtmeF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHRyYWN0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0T3B0aW9ucyhyYXcpIHtcbiAgICAgIGlmICghcmF3KSByZXR1cm4ge307IC8vIEV2YWwgc29sdXRpb25cblxuICAgICAgcmV0dXJuIGV2YWwoXCIoZnVuY3Rpb24oKSB7IHJldHVybiBcIi5jb25jYXQocmF3LCBcIn0pKClcIikpOyAvLyBQcmltaXRpdmUgdmVyc2lvbiAob25seSBzdXBwb3J0IGZsYXQgbm9uLW5lc3RlZCB2YWx1ZXMsIG5vIGFycmF5cyAsIG5vIG9iamVjdHMpXG4gICAgICAvLyByYXcgPSByYXcucmVwbGFjZSgveyguKil9LywgJyQxJyk7XG4gICAgICAvLyBsZXQgYXJncyA9IHJhdy5zcGxpdCgnLCcpLm1hcCggKGl0ZW0pID0+IGl0ZW0udHJpbSgpLnNwbGl0KCc6JykgKTtcbiAgICAgIC8vIGxldCByZXN1bHQgPSB7fTtcbiAgICAgIC8vIGFyZ3MuZm9yRWFjaChpdGVtID0+IHsgXG4gICAgICAvLyAgIGxldCB2YWwgPSBpdGVtWzFdLnRyaW0oKTtcbiAgICAgIC8vICAgaWYgKCFpc05hTih2YWwpKSB7IHZhbCA9ICt2YWw7IH1cbiAgICAgIC8vICAgZWxzZSBpZiAodmFsLmluZGV4T2YoXCInXCIpID09IDApIHsgdmFsID0gdmFsLnJlcGxhY2UoLycvZywgJycpOyB9XG4gICAgICAvLyAgIGVsc2UgaWYgKHZhbCA9PSAndHJ1ZScpIHsgdmFsID0gdHJ1ZTsgfVxuICAgICAgLy8gICBlbHNlIGlmICh2YWwgPT0gJ2ZhbHNlJykgeyB2YWwgPSBmYWxzZTsgfVxuICAgICAgLy8gICByZXN1bHRbaXRlbVswXS50cmltKCldID0gdmFsOyBcbiAgICAgIC8vIH0pO1xuICAgICAgLy8gcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KCk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n')},function(module,exports,__webpack_require__){eval("var api = __webpack_require__(3);\n            var content = __webpack_require__(12);\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZS9oZXJvLnNjc3M/MGMzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2hlcm8uc2Nzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n")},function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(4);\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, ".splitting .word,.splitting .char{display:inline-block}.splitting .char{position:relative}.splitting .char::before,.splitting .char::after{content:attr(data-char);position:absolute;top:0;left:0;visibility:hidden;transition:inherit;user-select:none}.splitting{--word-center: calc((var(--word-total) - 1) / 2);--char-center: calc((var(--char-total) - 1) / 2);--line-center: calc((var(--line-total) - 1) / 2)}.splitting .word{--word-percent: calc(var(--word-index) / var(--word-total));--line-percent: calc(var(--line-index) / var(--line-total))}.splitting .char{--char-percent: calc(var(--char-index) / var(--char-total));--char-offset: calc(var(--char-index) - var(--char-center));--distance: calc(\\n     (var(--char-offset) * var(--char-offset)) / var(--char-center)\\n  );--distance-sine: calc(var(--char-offset) / var(--char-center));--distance-percent: calc((var(--distance) / var(--char-center)))}\\n", ""]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZS9oZXJvLnNjc3M/NTcyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnNwbGl0dGluZyAud29yZCwuc3BsaXR0aW5nIC5jaGFye2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5zcGxpdHRpbmcgLmNoYXJ7cG9zaXRpb246cmVsYXRpdmV9LnNwbGl0dGluZyAuY2hhcjo6YmVmb3JlLC5zcGxpdHRpbmcgLmNoYXI6OmFmdGVye2NvbnRlbnQ6YXR0cihkYXRhLWNoYXIpO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDt2aXNpYmlsaXR5OmhpZGRlbjt0cmFuc2l0aW9uOmluaGVyaXQ7dXNlci1zZWxlY3Q6bm9uZX0uc3BsaXR0aW5ney0td29yZC1jZW50ZXI6IGNhbGMoKHZhcigtLXdvcmQtdG90YWwpIC0gMSkgLyAyKTstLWNoYXItY2VudGVyOiBjYWxjKCh2YXIoLS1jaGFyLXRvdGFsKSAtIDEpIC8gMik7LS1saW5lLWNlbnRlcjogY2FsYygodmFyKC0tbGluZS10b3RhbCkgLSAxKSAvIDIpfS5zcGxpdHRpbmcgLndvcmR7LS13b3JkLXBlcmNlbnQ6IGNhbGModmFyKC0td29yZC1pbmRleCkgLyB2YXIoLS13b3JkLXRvdGFsKSk7LS1saW5lLXBlcmNlbnQ6IGNhbGModmFyKC0tbGluZS1pbmRleCkgLyB2YXIoLS1saW5lLXRvdGFsKSl9LnNwbGl0dGluZyAuY2hhcnstLWNoYXItcGVyY2VudDogY2FsYyh2YXIoLS1jaGFyLWluZGV4KSAvIHZhcigtLWNoYXItdG90YWwpKTstLWNoYXItb2Zmc2V0OiBjYWxjKHZhcigtLWNoYXItaW5kZXgpIC0gdmFyKC0tY2hhci1jZW50ZXIpKTstLWRpc3RhbmNlOiBjYWxjKFxcbiAgICAgKHZhcigtLWNoYXItb2Zmc2V0KSAqIHZhcigtLWNoYXItb2Zmc2V0KSkgLyB2YXIoLS1jaGFyLWNlbnRlcilcXG4gICk7LS1kaXN0YW5jZS1zaW5lOiBjYWxjKHZhcigtLWNoYXItb2Zmc2V0KSAvIHZhcigtLWNoYXItY2VudGVyKSk7LS1kaXN0YW5jZS1wZXJjZW50OiBjYWxjKCh2YXIoLS1kaXN0YW5jZSkgLyB2YXIoLS1jaGFyLWNlbnRlcikpKX1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n')},,,function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/lodash.throttle/index.js\nvar lodash_throttle = __webpack_require__(8);\nvar lodash_throttle_default = /*#__PURE__*/__webpack_require__.n(lodash_throttle);\n\n// EXTERNAL MODULE: ./node_modules/lodash.debounce/index.js\nvar lodash_debounce = __webpack_require__(9);\nvar lodash_debounce_default = /*#__PURE__*/__webpack_require__.n(lodash_debounce);\n\n// CONCATENATED MODULE: ./src/hero/helper/Helper.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Helper_default =\n/*#__PURE__*/\nfunction () {\n  function _default() {\n    _classCallCheck(this, _default);\n  }\n\n  _createClass(_default, null, [{\n    key: "appendHtml",\n    value: function appendHtml(target, markup) {\n      target.insertAdjacentHTML(\'beforeend\', markup);\n      return target.lastChild;\n    }\n  }, {\n    key: "wrap",\n    value: function wrap(el, wrapper) {\n      el.parentNode.insertBefore(wrapper, el);\n      wrapper.appendChild(el);\n    }\n  }]);\n\n  return _default;\n}();\n\n\n// CONCATENATED MODULE: ./src/hero/core/Brain.js\nfunction Brain_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Brain_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Brain_createClass(Constructor, protoProps, staticProps) { if (protoProps) Brain_defineProperties(Constructor.prototype, protoProps); if (staticProps) Brain_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar LOG = \'[ Brain ]\';\nvar DEBUG = false;\n\nvar Brain_default =\n/*#__PURE__*/\nfunction () {\n  function _default() {\n    Brain_classCallCheck(this, _default);\n\n    DEBUG && console.log(LOG, \'constructor()\');\n  }\n\n  Brain_createClass(_default, [{\n    key: "add",\n    value: function add(p) {\n      console.log(LOG, \'add() p:\', p);\n    }\n  }]);\n\n  return _default;\n}();\n\n\n// EXTERNAL MODULE: ./src/hero/fx/FxBase.js\nvar FxBase = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/hero/core/Hero.js\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction Hero_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Hero_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Hero_createClass(Constructor, protoProps, staticProps) { if (protoProps) Hero_defineProperties(Constructor.prototype, protoProps); if (staticProps) Hero_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nvar Hero_LOG = \'[ Hero ]\';\nvar Hero_DEBUG = false;\n\nvar Hero_default =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Constructor\n   */\n  function _default() {\n    Hero_classCallCheck(this, _default);\n\n    _defineProperty(this, "brain", void 0);\n\n    this.brain = new Brain_default();\n    Hero_DEBUG && console.log(Hero_LOG, \'constructor()\');\n  }\n  /**\n   * Add\n   * For parameters also see addBehavior()\n   * @example\n   * \n   *  // Effect Behavior\n   *  hero.add(el, \'click\', hero.fx.Magnet, {delay: 100});\n   * \n   *  // Custom behavior\n   *  hero.add(el, \'toggle\', {\n   *    start: () => {\n   *      console.log(\'START\');\n   *    },\n   *    end: () => {\n   *      console.log(\'END\');\n   *    }\n   *  });\n   */\n\n\n  Hero_createClass(_default, [{\n    key: "add",\n    value: function add() {\n      // Delegate depending on signature\n      if (arguments[0] instanceof Element && (typeof arguments[1] === \'string\' || _typeof(arguments[1]) === \'object\' && typeof arguments[1].type === \'string\') && arguments[2].prototype instanceof hero.fx.FxBase) {\n        this.addEffectBehavior.apply(this, arguments);\n      } else if (arguments[0] instanceof Element && (typeof arguments[1] === \'string\' || _typeof(arguments[1]) === \'object\' && typeof arguments[1].type === \'string\') && _typeof(arguments[2]) === \'object\') {\n        this.addBehavior.apply(this, arguments);\n      } else {\n        console.log(Hero_LOG, \'add()\', \'unknown signature\');\n      }\n    }\n    /**\n     * Add Effect Behavior\n     * @param {HTMLElement} el The host element to add the behavior to\n     * @param {(string|object)} trigger The trigger type (e.g. click, hover, toggle etc.)\n     *                                  E.g. \'click\' or {type: \'hover\', area: \'#custom-trigger-area\'}\n     * @param {FxBase} Fx The effect class to apply (e.g. hero.fx.Magnet)\n     * @param {object} [fxOptions] Optional effect options (e.g {speed: 2})\n     */\n\n  }, {\n    key: "addEffectBehavior",\n    value: function addEffectBehavior(el, trigger, Fx, fxOptions) {\n      //---\n      // Create fx\n      fxOptions = fxOptions ? fxOptions : {};\n      var fx = new Fx(el, fxOptions);\n      el = fx.element;\n      this.addBehavior(el, trigger, fx, fxOptions ? fxOptions.id : undefined);\n    }\n    /**\n     * Add behavior\n     * (supports automatic area detection: if next node has attribute "hero-trigger-area" )\n     * @param {HTMLElement} el The host element to add the behavior to\n     * @param {(string|object)} trigger The trigger type (e.g. click, hover, toggle etc.)\n     *                                  E.g. \'click\' or {type: \'hover\', area: \'#custom-trigger-area\'}\n     * @param {Object} action Action object\n     * @param {Function} action.start Start function\n     * @param {Function} action.end End function\n     * @param {string} [id] Optional id\n     */\n\n  }, {\n    key: "addBehavior",\n    value: function addBehavior(el, trigger, action, id) {\n      Hero_DEBUG && console.log(Hero_LOG, \'addBehavior()\', el, trigger, action, id);\n      var triggerType = typeof trigger === \'string\' ? trigger : trigger.type,\n          standard = true,\n          startTrigger,\n          endTrigger; //---\n      // Area\n\n      var area = typeof trigger === \'string\' ? el : typeof trigger.area === \'string\' ? document.querySelector(trigger.area) : trigger.area;\n\n      if (area == el) {\n        // Auto detect area (next node has "hero-trigger-area" attribute)\n        if (el.nextElementSibling && el.nextElementSibling.hasAttribute(\'hero-fx-trigger-area\')) {\n          var svg = el.nextElementSibling.querySelector(\'svg\');\n\n          if (svg) {\n            var path = svg.querySelector(\'path\');\n            path.style.opacity = 0;\n            area = path;\n            area.style.pointerEvents = \'auto\';\n          } else {\n            area = el.nextElementSibling;\n          }\n\n          el.style.pointerEvents = \'none\';\n        }\n      } //---\n      // Trigger type\n\n\n      switch (triggerType) {\n        case \'\':\n        case \'auto\':\n        case \'load\':\n          standard = false;\n          break;\n\n        case \'click\':\n          startTrigger = \'click\';\n          break;\n\n        case \'hover\':\n          startTrigger = \'mouseenter\';\n          endTrigger = \'mouseleave\';\n          break;\n\n        case \'toggle\':\n          startTrigger = \'click\';\n          endTrigger = \'click\';\n          standard = false;\n          break;\n\n        default:\n          // e.g. mouseenter, mouseleave, blur, focus etc.\n          startTrigger = triggerType;\n      } //---\n      // Setup triggering (event listeners etc.)\n\n\n      if (standard) {\n        // startTrigger && area.addEventListener(startTrigger, startFunc);\n        // endTrigger && area.addEventListener(endTrigger, endFunc);\n        startTrigger && action.start && area.addEventListener(startTrigger, action.start.bind(action, el));\n        endTrigger && action.end && area.addEventListener(endTrigger, action.end.bind(action, el));\n      } else {\n        switch (triggerType) {\n          case \'\':\n          case \'auto\':\n          case \'load\':\n            action.start(el);\n            break;\n\n          case \'toggle\':\n            var on = true;\n            area.addEventListener(\'click\', function (evt) {\n              on ? action.start(el) : action.end(el);\n              on = !on;\n            });\n            break;\n        }\n      } //---\n      // Memorize on element level if fx has id\n      // if (id) {\n      //   DEBUG && console.log(LOG, \'addBehavior()\', \'Memorize on element with id:\', id);\n\n\n      this.prepareElement(el);\n      el.hero.fx.push(action); // }\n    }\n    /**\n     * Prepare element\n     */\n\n  }, {\n    key: "prepareElement",\n    value: function prepareElement(el) {\n      if (!el.hero) {\n        // Prepare namespace\n        el.hero = {\n          fx: [],\n          scanned: {}\n        }; // Add fx get function\n\n        el.hero.getFx = function (id) {\n          if (id) {\n            // First search custom ids\n            var fx = this.fx.find(function (item) {\n              return item.options && item.options.id == id;\n            });\n            fx = fx || this.fx.find(function (item) {\n              return item.type == id;\n            });\n            return fx;\n          } else {\n            return this.fx[0];\n          }\n        };\n      }\n    }\n  }]);\n\n  return _default;\n}();\n\n\n// EXTERNAL MODULE: ./src/hero/fx/FxScanner.js\nvar FxScanner = __webpack_require__(10);\n\n// CONCATENATED MODULE: ./src/hero/fx/core/Glitch.js\nfunction Glitch_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Glitch_typeof = function _typeof(obj) { return typeof obj; }; } else { Glitch_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Glitch_typeof(obj); }\n\nfunction Glitch_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Glitch_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Glitch_createClass(Constructor, protoProps, staticProps) { if (protoProps) Glitch_defineProperties(Constructor.prototype, protoProps); if (staticProps) Glitch_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (Glitch_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction Glitch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Glitch_LOG = \'[ FX : Glitch ]\';\nvar Glitch_DEBUG = false;\n\nvar Glitch_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  _inherits(_default, _FxBase);\n\n  // dpr = (!window.devicePixelRatio) ? 1 : (window.devicePixelRatio>=2) ? 2 : 1;\n  function _default() {\n    var _this;\n\n    Glitch_classCallCheck(this, _default);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_default).apply(this, arguments));\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "ready", false);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "playRequested", false);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "src", void 0);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "canvas", void 0);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "stage", void 0);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "width", void 0);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "height", void 0);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "naturalWidth", void 0);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "naturalHeight", void 0);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "dpr", 2);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "scale", void 0);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "segments", []);\n\n    _get(_getPrototypeOf(_default.prototype), "init", _assertThisInitialized(_this)).call(_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Glitch_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      // Save original image\n      this.original = this.element;\n      this.src = this.original.getAttribute(\'src\'); // Make sure image is fully loaded before creating\n\n      this.original.complete ? this.create() : this.original.addEventListener(\'load\', this.create.bind(this));\n    }\n  }, {\n    key: "create",\n    value: function create() {\n      var _this2 = this;\n\n      Glitch_DEBUG && console.log(Glitch_LOG, \'create()\');\n\n      try {\n        this.naturalWidth = this.original.naturalWidth;\n        this.naturalHeight = this.original.naturalHeight; // Create canvas\n\n        var canvas = this.canvas = document.createElement(\'canvas\');\n        this.original.getAttribute(\'id\') && canvas.setAttribute(\'id\', this.original.getAttribute(\'id\'));\n        this.stage = new createjs.Stage(this.canvas);\n        this.original.parentNode.insertBefore(this.canvas, this.original.nextSibling);\n        var computedStyle = window.getComputedStyle(this.original); // let computedStyle = window.getComputedStyle(this.original);\n        // canvas.style.width = computedStyle.width;\n\n        canvas.style.width = computedStyle.width;\n        canvas.style.height = computedStyle.height;\n        canvas.style.left = computedStyle.left;\n        canvas.style.top = computedStyle.top;\n        canvas.style.transform = computedStyle.transform; // canvas.style.pointerEvents = \'none\';\n\n        this.width = parseInt(computedStyle.width) * this.dpr;\n        this.height = parseInt(computedStyle.height) * this.dpr;\n        this.scale = this.width / this.naturalWidth;\n        this.scale = this.height / this.naturalHeight; // canvas.width = canvas.clientWidth;\n        // canvas.height = canvas.clientHeight;\n\n        canvas.width = this.width;\n        canvas.height = this.height;\n        this.element = this.canvas; // this.original.parentNode.removeChild(this.original);\n        // this.original.remove();\n\n        this.original.removeAttribute(\'id\');\n        this.original.style.display = \'none\'; // Create segments\n\n        var seedIndex = 0,\n            top = 0;\n\n        while (true) {\n          var seed = Math.round(this.options.seed[seedIndex] * this.options.factor);\n          var image = new createjs.Bitmap(this.src);\n          var shape = new createjs.Shape();\n          shape.graphics.beginFill("#FFFFFF").drawRect(0, top, this.width, seed);\n          image.mask = shape;\n          image.scale = this.scale;\n          this.stage.addChild(image);\n          this.segments.push(image); // End\n          // if (top >= parseInt(computedStyle.height) * this.dpr) break;\n\n          if (top >= this.height * this.dpr) break; // TEMP\n          // TEMP\n          // TEMP\n          // if (top > 100) break\n          // Iterate \n\n          top += seed;\n          seedIndex = seedIndex >= this.options.seed.length - 1 ? 0 : ++seedIndex;\n        } // Timeline\n\n\n        this.timeline = gsap.timeline({\n          paused: true,\n          delay: this.options.delay / 1000,\n          repeat: this.options.repeat,\n          repeatDelay: this.options.repeatDelay / 1000,\n          yoyo: this.options.yoyo,\n          onUpdate: this.stage.update.bind(this.stage)\n        });\n        this.segments.forEach(function (segment, index) {\n          _this2.timeline.from(segment, {\n            x: (Math.random() - .5) * 20 * _this2.options.power,\n            alpha: 0,\n            duration: 0.5,\n            ease: _this2.options.easeing\n          }, "".concat(index * _this2.options.stagger / 1000));\n        });\n        this.timeline.timeScale(this.timeline.duration() / (this.options.duration / 1000));\n        this.ready = true;\n        this.playRequested && this.timeline.play();\n      } catch (err) {\n        console.log(Glitch_LOG, \'Error\', err);\n      }\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      if (this.ready) {\n        this.timeline.play();\n      } else {\n        this.playRequested = true;\n      }\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      this.timeline.reverse();\n    }\n  }, {\n    key: "reset",\n    value: function reset() {\n      this.timeline.pause(0);\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nGlitch_defineProperty(Glitch_default, "manifest", {\n  id: \'glitch\',\n  options: {\n    trigger: \'load\',\n    duration: 1000,\n    delay: 100,\n    repeat: 0,\n    repeatDelay: 1000,\n    yoyo: true,\n    seed: [1, 6, 3, 1, 3, 8, 2, 1, 9, 4, 7, 1],\n    factor: 10,\n    power: 80,\n    stagger: 10,\n    easing: \'power4.inOut\' // back.out(3),\n\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/core/Magnet.js\nfunction Magnet_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Magnet_typeof = function _typeof(obj) { return typeof obj; }; } else { Magnet_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Magnet_typeof(obj); }\n\nfunction Magnet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Magnet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Magnet_createClass(Constructor, protoProps, staticProps) { if (protoProps) Magnet_defineProperties(Constructor.prototype, protoProps); if (staticProps) Magnet_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Magnet_possibleConstructorReturn(self, call) { if (call && (Magnet_typeof(call) === "object" || typeof call === "function")) { return call; } return Magnet_assertThisInitialized(self); }\n\nfunction Magnet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Magnet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Magnet_setPrototypeOf(subClass, superClass); }\n\nfunction Magnet_setPrototypeOf(o, p) { Magnet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Magnet_setPrototypeOf(o, p); }\n\nfunction Magnet_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Magnet_get = Reflect.get; } else { Magnet_get = function _get(target, property, receiver) { var base = Magnet_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Magnet_get(target, property, receiver || target); }\n\nfunction Magnet_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Magnet_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Magnet_getPrototypeOf(o) { Magnet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Magnet_getPrototypeOf(o); }\n\nfunction Magnet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Magnet_LOG = \'[ FX : Magnet ]\';\nvar Magnet_DEBUG = false;\n\nvar Magnet_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Magnet_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Magnet_classCallCheck(this, _default);\n\n    _this = Magnet_possibleConstructorReturn(this, Magnet_getPrototypeOf(_default).apply(this, arguments));\n\n    Magnet_get(Magnet_getPrototypeOf(_default.prototype), "init", Magnet_assertThisInitialized(_this)).call(Magnet_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Magnet_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      this.element.style.cursor = \'pointer\';\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      gsap.to(this.element, {\n        scale: this.options.scale,\n        transformOrigin: \'50% 50%\',\n        delay: this.options.delay / 1000,\n        duration: this.options.duration / 1000,\n        ease: \'power4.out(9)\'\n      });\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      gsap.isTweening(this.element) && gsap.killTweensOf(this.element, \'scale\');\n      gsap.to(this.element, {\n        scale: 1,\n        duration: this.options.duration / 1000,\n        ease: this.options.easeOut\n      });\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nMagnet_defineProperty(Magnet_default, "manifest", {\n  id: \'magnet\',\n  options: {\n    trigger: \'hover\',\n    delay: 0,\n    duration: 500,\n    scale: 1.2,\n    easeOut: \'back.out(3)\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/core/Sequence.js\nfunction Sequence_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Sequence_typeof = function _typeof(obj) { return typeof obj; }; } else { Sequence_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Sequence_typeof(obj); }\n\nfunction Sequence_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Sequence_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Sequence_createClass(Constructor, protoProps, staticProps) { if (protoProps) Sequence_defineProperties(Constructor.prototype, protoProps); if (staticProps) Sequence_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Sequence_possibleConstructorReturn(self, call) { if (call && (Sequence_typeof(call) === "object" || typeof call === "function")) { return call; } return Sequence_assertThisInitialized(self); }\n\nfunction Sequence_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Sequence_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Sequence_setPrototypeOf(subClass, superClass); }\n\nfunction Sequence_setPrototypeOf(o, p) { Sequence_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Sequence_setPrototypeOf(o, p); }\n\nfunction Sequence_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Sequence_get = Reflect.get; } else { Sequence_get = function _get(target, property, receiver) { var base = Sequence_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Sequence_get(target, property, receiver || target); }\n\nfunction Sequence_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Sequence_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Sequence_getPrototypeOf(o) { Sequence_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Sequence_getPrototypeOf(o); }\n\nfunction Sequence_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Sequence_LOG = \'[ FX : Sequence ]\';\nvar Sequence_DEBUG = true;\n\nvar Sequence_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Sequence_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Sequence_classCallCheck(this, _default);\n\n    _this = Sequence_possibleConstructorReturn(this, Sequence_getPrototypeOf(_default).apply(this, arguments));\n\n    Sequence_defineProperty(Sequence_assertThisInitialized(_this), "steps", []);\n\n    Sequence_defineProperty(Sequence_assertThisInitialized(_this), "timeline", void 0);\n\n    Sequence_get(Sequence_getPrototypeOf(_default.prototype), "init", Sequence_assertThisInitialized(_this)).call(Sequence_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Sequence_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      Sequence_DEBUG && console.log(Sequence_LOG, \'init()\'); // DEBUG && console.log(LOG, \'init()\', \'this.element.children:\', this.element.children);\n\n      for (var i = 0; i < this.element.children.length; i++) {\n        this.steps.push(this.element.children[i]);\n      }\n\n      this.steps.reverse();\n      Sequence_DEBUG && console.log(Sequence_LOG, \'init()\', \'steps:\', this.steps);\n      gsap.set(this.steps, {\n        opacity: 0\n      });\n      gsap.set(this.steps[0], {\n        opacity: 1\n      });\n      var tl = this.timeline = gsap.timeline({\n        paused: true,\n        delay: this.options.delay / 1000,\n        repeat: this.options.repeat,\n        repeatDelay: this.options.repeatDelay / 1000,\n        yoyo: this.options.yoyo\n      });\n      this.steps.forEach(function (item, index) {\n        tl.to(item, {\n          opacity: 1,\n          duration: 0\n        }, index * _this2.options.stepDuration / 1000);\n        var last = index >= _this2.steps.length - 1;\n\n        if (!last) {\n          tl.to(item, {\n            opacity: 0,\n            duration: 0\n          }, (index + 1) * _this2.options.stepDuration / 1000);\n        }\n      });\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      this.timeline.play(0);\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      this.timeline.pause(0);\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nSequence_defineProperty(Sequence_default, "manifest", {\n  id: \'sequence\',\n  options: {\n    trigger: \'load\',\n    delay: 200,\n    stepDuration: 90,\n    repeatDelay: 500,\n    yoyo: true,\n    repeat: -1\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/core/Appear.js\nfunction Appear_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Appear_typeof = function _typeof(obj) { return typeof obj; }; } else { Appear_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Appear_typeof(obj); }\n\nfunction Appear_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Appear_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Appear_createClass(Constructor, protoProps, staticProps) { if (protoProps) Appear_defineProperties(Constructor.prototype, protoProps); if (staticProps) Appear_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Appear_possibleConstructorReturn(self, call) { if (call && (Appear_typeof(call) === "object" || typeof call === "function")) { return call; } return Appear_assertThisInitialized(self); }\n\nfunction Appear_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Appear_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Appear_setPrototypeOf(subClass, superClass); }\n\nfunction Appear_setPrototypeOf(o, p) { Appear_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Appear_setPrototypeOf(o, p); }\n\nfunction Appear_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Appear_get = Reflect.get; } else { Appear_get = function _get(target, property, receiver) { var base = Appear_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Appear_get(target, property, receiver || target); }\n\nfunction Appear_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Appear_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Appear_getPrototypeOf(o) { Appear_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Appear_getPrototypeOf(o); }\n\nfunction Appear_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Appear_LOG = \'[ FX : Appear ]\';\nvar Appear_DEBUG = false;\n\nvar Appear_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Appear_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Appear_classCallCheck(this, _default);\n\n    _this = Appear_possibleConstructorReturn(this, Appear_getPrototypeOf(_default).apply(this, arguments));\n\n    Appear_get(Appear_getPrototypeOf(_default.prototype), "init", Appear_assertThisInitialized(_this)).call(Appear_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Appear_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      gsap.set(this.element, {\n        opacity: 0\n      });\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      gsap.to(this.element, {\n        opacity: 1,\n        delay: this.options.delay / 1000,\n        duration: this.options.duration / 1000\n      });\n    }\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nAppear_defineProperty(Appear_default, "manifest", {\n  id: \'appear\',\n  options: {\n    trigger: \'load\',\n    delay: 0,\n    duration: 500\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/core/Hide.js\nfunction Hide_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Hide_typeof = function _typeof(obj) { return typeof obj; }; } else { Hide_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Hide_typeof(obj); }\n\nfunction Hide_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Hide_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Hide_createClass(Constructor, protoProps, staticProps) { if (protoProps) Hide_defineProperties(Constructor.prototype, protoProps); if (staticProps) Hide_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Hide_possibleConstructorReturn(self, call) { if (call && (Hide_typeof(call) === "object" || typeof call === "function")) { return call; } return Hide_assertThisInitialized(self); }\n\nfunction Hide_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Hide_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Hide_setPrototypeOf(subClass, superClass); }\n\nfunction Hide_setPrototypeOf(o, p) { Hide_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Hide_setPrototypeOf(o, p); }\n\nfunction Hide_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Hide_get = Reflect.get; } else { Hide_get = function _get(target, property, receiver) { var base = Hide_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Hide_get(target, property, receiver || target); }\n\nfunction Hide_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Hide_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Hide_getPrototypeOf(o) { Hide_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Hide_getPrototypeOf(o); }\n\nfunction Hide_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Hide_LOG = \'[ FX : Hide ]\';\nvar Hide_DEBUG = false;\n\nvar Hide_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Hide_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Hide_classCallCheck(this, _default);\n\n    _this = Hide_possibleConstructorReturn(this, Hide_getPrototypeOf(_default).apply(this, arguments));\n\n    Hide_get(Hide_getPrototypeOf(_default.prototype), "init", Hide_assertThisInitialized(_this)).call(Hide_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Hide_createClass(_default, [{\n    key: "init",\n    value: function init() {}\n  }, {\n    key: "start",\n    value: function start() {\n      gsap.to(this.element, {\n        opacity: 0,\n        delay: this.options.delay / 1000,\n        duration: this.options.duration / 1000\n      });\n    }\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nHide_defineProperty(Hide_default, "manifest", {\n  id: \'hide\',\n  options: {\n    trigger: \'load\',\n    delay: 0,\n    duration: 500\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/core/Invisible.js\nfunction Invisible_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Invisible_typeof = function _typeof(obj) { return typeof obj; }; } else { Invisible_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Invisible_typeof(obj); }\n\nfunction Invisible_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Invisible_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Invisible_createClass(Constructor, protoProps, staticProps) { if (protoProps) Invisible_defineProperties(Constructor.prototype, protoProps); if (staticProps) Invisible_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Invisible_possibleConstructorReturn(self, call) { if (call && (Invisible_typeof(call) === "object" || typeof call === "function")) { return call; } return Invisible_assertThisInitialized(self); }\n\nfunction Invisible_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Invisible_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Invisible_setPrototypeOf(subClass, superClass); }\n\nfunction Invisible_setPrototypeOf(o, p) { Invisible_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Invisible_setPrototypeOf(o, p); }\n\nfunction Invisible_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Invisible_get = Reflect.get; } else { Invisible_get = function _get(target, property, receiver) { var base = Invisible_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Invisible_get(target, property, receiver || target); }\n\nfunction Invisible_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Invisible_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Invisible_getPrototypeOf(o) { Invisible_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Invisible_getPrototypeOf(o); }\n\nfunction Invisible_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Invisible_LOG = \'[ FX : Insivible ]\';\nvar Invisible_DEBUG = false;\n\nvar Invisible_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Invisible_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Invisible_classCallCheck(this, _default);\n\n    _this = Invisible_possibleConstructorReturn(this, Invisible_getPrototypeOf(_default).apply(this, arguments));\n\n    Invisible_get(Invisible_getPrototypeOf(_default.prototype), "init", Invisible_assertThisInitialized(_this)).call(Invisible_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Invisible_createClass(_default, [{\n    key: "init",\n    value: function init() {}\n  }, {\n    key: "start",\n    value: function start() {\n      this.element.style.opacity = 0;\n    }\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nInvisible_defineProperty(Invisible_default, "manifest", {\n  id: \'invisible\',\n  options: {\n    trigger: \'load\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/core/NoPointerEvents.js\nfunction NoPointerEvents_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { NoPointerEvents_typeof = function _typeof(obj) { return typeof obj; }; } else { NoPointerEvents_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return NoPointerEvents_typeof(obj); }\n\nfunction NoPointerEvents_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction NoPointerEvents_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction NoPointerEvents_createClass(Constructor, protoProps, staticProps) { if (protoProps) NoPointerEvents_defineProperties(Constructor.prototype, protoProps); if (staticProps) NoPointerEvents_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction NoPointerEvents_possibleConstructorReturn(self, call) { if (call && (NoPointerEvents_typeof(call) === "object" || typeof call === "function")) { return call; } return NoPointerEvents_assertThisInitialized(self); }\n\nfunction NoPointerEvents_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction NoPointerEvents_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) NoPointerEvents_setPrototypeOf(subClass, superClass); }\n\nfunction NoPointerEvents_setPrototypeOf(o, p) { NoPointerEvents_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return NoPointerEvents_setPrototypeOf(o, p); }\n\nfunction NoPointerEvents_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { NoPointerEvents_get = Reflect.get; } else { NoPointerEvents_get = function _get(target, property, receiver) { var base = NoPointerEvents_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return NoPointerEvents_get(target, property, receiver || target); }\n\nfunction NoPointerEvents_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = NoPointerEvents_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction NoPointerEvents_getPrototypeOf(o) { NoPointerEvents_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return NoPointerEvents_getPrototypeOf(o); }\n\nfunction NoPointerEvents_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar NoPointerEvents_LOG = \'[ FX : NoPointerEvents ]\';\nvar NoPointerEvents_DEBUG = false;\n\nvar NoPointerEvents_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  NoPointerEvents_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    NoPointerEvents_classCallCheck(this, _default);\n\n    _this = NoPointerEvents_possibleConstructorReturn(this, NoPointerEvents_getPrototypeOf(_default).apply(this, arguments));\n\n    NoPointerEvents_get(NoPointerEvents_getPrototypeOf(_default.prototype), "init", NoPointerEvents_assertThisInitialized(_this)).call(NoPointerEvents_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  NoPointerEvents_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      this.element.style.pointerEvents = \'none\';\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nNoPointerEvents_defineProperty(NoPointerEvents_default, "manifest", {\n  id: \'no-pointer-events\',\n  options: {\n    trigger: \'none\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/core/Parallax.js\nfunction Parallax_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Parallax_typeof = function _typeof(obj) { return typeof obj; }; } else { Parallax_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Parallax_typeof(obj); }\n\nfunction Parallax_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Parallax_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Parallax_createClass(Constructor, protoProps, staticProps) { if (protoProps) Parallax_defineProperties(Constructor.prototype, protoProps); if (staticProps) Parallax_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Parallax_possibleConstructorReturn(self, call) { if (call && (Parallax_typeof(call) === "object" || typeof call === "function")) { return call; } return Parallax_assertThisInitialized(self); }\n\nfunction Parallax_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Parallax_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Parallax_setPrototypeOf(subClass, superClass); }\n\nfunction Parallax_setPrototypeOf(o, p) { Parallax_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Parallax_setPrototypeOf(o, p); }\n\nfunction Parallax_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Parallax_get = Reflect.get; } else { Parallax_get = function _get(target, property, receiver) { var base = Parallax_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Parallax_get(target, property, receiver || target); }\n\nfunction Parallax_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Parallax_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Parallax_getPrototypeOf(o) { Parallax_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Parallax_getPrototypeOf(o); }\n\nfunction Parallax_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Parallax\n\nvar Parallax_LOG = \'[ FX : Parallax ]\';\nvar Parallax_DEBUG = true;\n\nvar Parallax_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Parallax_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Parallax_classCallCheck(this, _default);\n\n    _this = Parallax_possibleConstructorReturn(this, Parallax_getPrototypeOf(_default).apply(this, arguments));\n\n    Parallax_defineProperty(Parallax_assertThisInitialized(_this), "layers", []);\n\n    Parallax_get(Parallax_getPrototypeOf(_default.prototype), "init", Parallax_assertThisInitialized(_this)).call(Parallax_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Parallax_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      Parallax_DEBUG && console.log(Parallax_LOG, \'init()\'); // #IDEA: Mobile: auto animation\n      // #IDEA: Idle: auto animation?\n\n      var viewportWidth = parseFloat(window.getComputedStyle(this.element).width);\n      var viewportHeight = parseFloat(window.getComputedStyle(this.element).height); // Layers\n\n      var layerElements = this.element.querySelectorAll(\'[hero-fx-parallax-layer]\');\n      layerElements.forEach(function (item) {\n        var attr = item.getAttribute(\'hero-fx-parallax-layer\');\n        var options = hero.fx.FxScanner.extractOptions(attr);\n        options.element = item;\n        options.x = $(item).position().left;\n        options.y = $(item).position().top;\n\n        _this2.layers.push(options);\n      });\n      Parallax_DEBUG && console.log(Parallax_LOG, \'init()\', \'this.layers\', this.layers);\n      this.element.addEventListener(\'mousemove\', function (evt) {\n        var x = evt.clientX - evt.currentTarget.getBoundingClientRect().left;\n        var y = evt.clientY - evt.currentTarget.getBoundingClientRect().top;\n        var percentX = (viewportWidth / 2 - x) / (viewportWidth / 2);\n        var percentY = (viewportHeight / 2 - y) / (viewportHeight / 2);\n\n        _this2.layers.forEach(function (item) {\n          gsap.to(item.element, 1, {\n            x: "".concat(item.x + viewportWidth * percentX * item.z / 10000),\n            y: "".concat(item.y + viewportHeight * percentY * item.z / 20000),\n            ease: "power2.out"\n          });\n        });\n      });\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nParallax_defineProperty(Parallax_default, "manifest", {\n  id: \'parallax\',\n  options: {\n    trigger: \'load\'\n  }\n});\n\n\n// EXTERNAL MODULE: ./node_modules/splitting/dist/splitting.js\nvar splitting = __webpack_require__(6);\nvar splitting_default = /*#__PURE__*/__webpack_require__.n(splitting);\n\n// CONCATENATED MODULE: ./src/hero/fx/type/TypeAnimation.js\nfunction TypeAnimation_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { TypeAnimation_typeof = function _typeof(obj) { return typeof obj; }; } else { TypeAnimation_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return TypeAnimation_typeof(obj); }\n\nfunction TypeAnimation_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TypeAnimation_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TypeAnimation_createClass(Constructor, protoProps, staticProps) { if (protoProps) TypeAnimation_defineProperties(Constructor.prototype, protoProps); if (staticProps) TypeAnimation_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction TypeAnimation_possibleConstructorReturn(self, call) { if (call && (TypeAnimation_typeof(call) === "object" || typeof call === "function")) { return call; } return TypeAnimation_assertThisInitialized(self); }\n\nfunction TypeAnimation_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TypeAnimation_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) TypeAnimation_setPrototypeOf(subClass, superClass); }\n\nfunction TypeAnimation_setPrototypeOf(o, p) { TypeAnimation_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TypeAnimation_setPrototypeOf(o, p); }\n\nfunction TypeAnimation_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { TypeAnimation_get = Reflect.get; } else { TypeAnimation_get = function _get(target, property, receiver) { var base = TypeAnimation_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return TypeAnimation_get(target, property, receiver || target); }\n\nfunction TypeAnimation_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = TypeAnimation_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction TypeAnimation_getPrototypeOf(o) { TypeAnimation_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TypeAnimation_getPrototypeOf(o); }\n\nfunction TypeAnimation_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\n\nvar TypeAnimation_LOG = \'[ FX : TypeAnimation ]\';\nvar TypeAnimation_DEBUG = false;\n\nvar TypeAnimation_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  TypeAnimation_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    TypeAnimation_classCallCheck(this, _default);\n\n    _this = TypeAnimation_possibleConstructorReturn(this, TypeAnimation_getPrototypeOf(_default).apply(this, arguments));\n\n    TypeAnimation_defineProperty(TypeAnimation_assertThisInitialized(_this), "characters", void 0);\n\n    TypeAnimation_get(TypeAnimation_getPrototypeOf(_default.prototype), "init", TypeAnimation_assertThisInitialized(_this)).call(TypeAnimation_assertThisInitialized(_this));\n\n    TypeAnimation_get(TypeAnimation_getPrototypeOf(_default.prototype), "start", TypeAnimation_assertThisInitialized(_this)).call(TypeAnimation_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  TypeAnimation_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      TypeAnimation_DEBUG && console.log(TypeAnimation_LOG, \'init()\', this.options); // Case1: no lines\n      // Case2: with lines\n      // Lines\n\n      if (this.options.lines) {\n        this.options.lines.unshift(this.element.textContent);\n        this.element.innerText = \'\';\n        this.options.lines.forEach(function (item) {\n          hero.helper.appendHtml(_this2.element, "<span class=\\"line\\" data-splitting=\\"\\">".concat(item, "</span>"));\n        });\n      }\n\n      splitting_default()();\n      hero.helper.appendHtml(this.element, "<div class=\\"cursor\\" style=\\"display: inline-block; opacity: 1; margin-left: 6px; max-width: 3px; color: transparent; background-color: black;\\">|</div>");\n      var cursor = this.element.querySelector(\'.cursor\');\n      var tl = gsap.timeline({\n        repeat: -1\n      });\n      this.element.querySelectorAll(\'.line\').forEach(function (line, index) {\n        gsap.set(line, {\n          display: \'none\'\n        });\n        var chars = line.querySelectorAll(\'.char\');\n        chars = [].slice.call(chars);\n        tl.to(line, {\n          display: \'inline\',\n          duration: 0\n        });\n        tl.fromTo(chars, {\n          display: \'none\'\n        }, {\n          display: \'inline\',\n          duration: 0.01,\n          stagger: 0.07\n        });\n        tl.to({}, {\n          duration: 1.7\n        });\n        tl.to(chars.reverse(), {\n          display: \'none\',\n          duration: 0.01,\n          stagger: 0.01\n        });\n        tl.to(line, {\n          display: \'none\',\n          duration: 0\n        });\n        tl.to({}, {\n          duration: 0.1\n        });\n      }); // this.characters = this.element.querySelectorAll(\'.char\');\n      // // console.log(\'list\', this.options.lines);\n      // // Initial state\n      // gsap.set(this.characters, {opacity: 0});    \n    }\n  }, {\n    key: "start",\n    value: function start() {\n      TypeAnimation_DEBUG && console.log(TypeAnimation_LOG, \'start()\'); // gsap.set(this.element, {\n      //   // skewY: -10,\n      //   // force3D: true\n      // });\n      // gsap.fromTo(this.characters, {\n      //   scale: 2,\n      // },\n      // { opacity: 1, scale: 1,\n      //   delay: this.options.delay/1000, duration: 0.4, \n      //   stagger: this.options.stagger/1000,\n      //   ease: \'power.out(6)\'\n      // });\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nTypeAnimation_defineProperty(TypeAnimation_default, "manifest", {\n  id: \'type\',\n  options: {\n    trigger: \'load\',\n    stagger: 100,\n    delay: 500,\n    lines: null\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/type/TypeSpin.js\nfunction TypeSpin_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { TypeSpin_typeof = function _typeof(obj) { return typeof obj; }; } else { TypeSpin_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return TypeSpin_typeof(obj); }\n\nfunction TypeSpin_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TypeSpin_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TypeSpin_createClass(Constructor, protoProps, staticProps) { if (protoProps) TypeSpin_defineProperties(Constructor.prototype, protoProps); if (staticProps) TypeSpin_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction TypeSpin_possibleConstructorReturn(self, call) { if (call && (TypeSpin_typeof(call) === "object" || typeof call === "function")) { return call; } return TypeSpin_assertThisInitialized(self); }\n\nfunction TypeSpin_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TypeSpin_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) TypeSpin_setPrototypeOf(subClass, superClass); }\n\nfunction TypeSpin_setPrototypeOf(o, p) { TypeSpin_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TypeSpin_setPrototypeOf(o, p); }\n\nfunction TypeSpin_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { TypeSpin_get = Reflect.get; } else { TypeSpin_get = function _get(target, property, receiver) { var base = TypeSpin_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return TypeSpin_get(target, property, receiver || target); }\n\nfunction TypeSpin_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = TypeSpin_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction TypeSpin_getPrototypeOf(o) { TypeSpin_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TypeSpin_getPrototypeOf(o); }\n\nfunction TypeSpin_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\n\nvar TypeSpin_LOG = \'[ FX : TypeSpin ]\';\nvar TypeSpin_DEBUG = false;\n\nvar TypeSpin_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  TypeSpin_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    TypeSpin_classCallCheck(this, _default);\n\n    _this = TypeSpin_possibleConstructorReturn(this, TypeSpin_getPrototypeOf(_default).apply(this, arguments));\n\n    TypeSpin_defineProperty(TypeSpin_assertThisInitialized(_this), "characters", void 0);\n\n    TypeSpin_get(TypeSpin_getPrototypeOf(_default.prototype), "init", TypeSpin_assertThisInitialized(_this)).call(TypeSpin_assertThisInitialized(_this));\n\n    TypeSpin_get(TypeSpin_getPrototypeOf(_default.prototype), "start", TypeSpin_assertThisInitialized(_this)).call(TypeSpin_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  TypeSpin_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      TypeSpin_DEBUG && console.log(TypeSpin_LOG, \'init()\', this.options); // Case1: no lines\n      // Case2: with lines\n      // Lines\n      // if (this.options.lines) {\n      //   this.options.lines.unshift(this.element.textContent)\n      //   this.element.innerText = \'\'\n      //   this.options.lines.forEach(item => {\n      //     hero.helper.appendHtml( this.element, `<span class="line" data-splitting="">${item}</span>` );\n      //   })\n      // }\n\n      this.options.width = this.element.getBoundingClientRect().width;\n      this.options.height = this.element.getBoundingClientRect().height;\n      this.element.style.width = this.options.width + \'px\';\n      this.element.style.height = this.options.height + \'px\';\n      this.element.style.overflow = \'hidden\';\n      this.element.style.position = \'relative\';\n      var textContent = this.element.textContent; // Empty\n\n      while (this.element.firstChild) {\n        this.element.removeChild(this.element.lastChild);\n      } // this.element.style.border = \'1px solid #777\';\n      // Add content twice\n\n\n      hero.helper.appendHtml(this.element, "\\n      <div class=\\"line1\\" style=\\"position: absolute; top: 0; left: 0;\\">".concat(textContent, "</div>\\n      <div class=\\"line2\\" style=\\"position: absolute; top: 0; left: 0;\\">").concat(textContent, "</div>")); // splitting();\n\n      var line1 = this.element.querySelector(\'.line1\');\n      var line2 = this.element.querySelector(\'.line2\');\n      gsap.set(line2, {\n        y: this.options.height\n      });\n      this.timeline = gsap.timeline({\n        repeat: 0,\n        paused: true\n      }).to(line1, {\n        y: -this.options.height,\n        duration: this.options.duration / 1000\n      }).to(line2, {\n        y: 0,\n        duration: this.options.duration / 1000\n      }, \'-= 0.5\');\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      TypeSpin_DEBUG && console.log(TypeSpin_LOG, \'start()\');\n      this.timeline.play();\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      TypeSpin_DEBUG && console.log(TypeSpin_LOG, \'start()\');\n      this.timeline.reverse();\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nTypeSpin_defineProperty(TypeSpin_default, "manifest", {\n  id: \'type-spin\',\n  options: {\n    trigger: \'hover\',\n    // stagger: 100,\n    // delay: 500,\n    duration: 500\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/experimental/Particles.js\nfunction Particles_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Particles_typeof = function _typeof(obj) { return typeof obj; }; } else { Particles_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Particles_typeof(obj); }\n\nfunction Particles_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Particles_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Particles_createClass(Constructor, protoProps, staticProps) { if (protoProps) Particles_defineProperties(Constructor.prototype, protoProps); if (staticProps) Particles_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Particles_possibleConstructorReturn(self, call) { if (call && (Particles_typeof(call) === "object" || typeof call === "function")) { return call; } return Particles_assertThisInitialized(self); }\n\nfunction Particles_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Particles_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Particles_setPrototypeOf(subClass, superClass); }\n\nfunction Particles_setPrototypeOf(o, p) { Particles_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Particles_setPrototypeOf(o, p); }\n\nfunction Particles_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Particles_get = Reflect.get; } else { Particles_get = function _get(target, property, receiver) { var base = Particles_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Particles_get(target, property, receiver || target); }\n\nfunction Particles_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Particles_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Particles_getPrototypeOf(o) { Particles_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Particles_getPrototypeOf(o); }\n\nfunction Particles_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Particles_LOG = \'[ FX : Particles ]\';\nvar Particles_DEBUG = true;\n\nvar Particles_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Particles_inherits(_default, _FxBase);\n\n  // Effect center\n  function _default() {\n    var _this;\n\n    Particles_classCallCheck(this, _default);\n\n    _this = Particles_possibleConstructorReturn(this, Particles_getPrototypeOf(_default).apply(this, arguments));\n\n    Particles_defineProperty(Particles_assertThisInitialized(_this), "center", {\n      left: 0,\n      top: 0\n    });\n\n    Particles_get(Particles_getPrototypeOf(_default.prototype), "init", Particles_assertThisInitialized(_this)).call(Particles_assertThisInitialized(_this));\n\n    return _this;\n  } // TEMP: Use FusionHelper instead\n  // TEMP: Use FusionHelper instead\n\n\n  Particles_createClass(_default, [{\n    key: "appendHtml",\n    value: function appendHtml(target, markup) {\n      target.insertAdjacentHTML(\'beforeend\', markup);\n      return target.lastChild;\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      Particles_DEBUG && console.log(Particles_LOG, \'init()\', this.options);\n      this.appendHtml(document.body, "<svg xmlns=\\"http://www.w3.org/2000/svg\\" xmlns:xlink=\\"http://www.w3.org/1999/xlink\\" width=\\"82\\" height=\\"129\\" viewBox=\\"0 0 82 129\\" style=\\"display: none\\">\\n      <circle id=\\"tplCircle\\" cx=\\"9.5\\" cy=\\"9.5\\" r=\\"9.5\\" fill=\\"none\\" stroke=\\"#fff\\" stroke-width=\\"3\\"/>\\n      <path id=\\"tplTriangle\\" d=\\"M9.5,0,19,17H0Z\\" fill=\\"none\\" stroke=\\"#fff\\" stroke-width=\\"3\\"/>\\n      <rect id=\\"tplRect\\" width=\\"19\\" height=\\"19\\" fill=\\"none\\" stroke=\\"#fff\\" stroke-width=\\"3\\"/>\\n    </svg>"); // Gather templates\n\n      this.templates = [{\n        node: document.getElementById(\'tplCircle\')\n      }, {\n        node: document.getElementById(\'tplTriangle\')\n      }, {\n        node: document.getElementById(\'tplRect\')\n      }]; // Cache width/height\n\n      this.templates.forEach(function (item) {\n        var rect = item.node.getBoundingClientRect();\n        item.width = rect.width;\n        item.height = rect.height;\n      });\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      Particles_DEBUG && console.log(Particles_LOG, \'update()\'); // let computedStyle = window.getComputedStyle(this.element);\n      // this.center = {\n      //   left: parseInt(computedStyle.left) + parseInt(computedStyle.width)/2,\n      //   top: parseInt(computedStyle.top) + parseInt(computedStyle.height)/2 \n      // };\n      // DEBUG && console.log(LOG, \'update() center:\', this.center);\n\n      function getLocalBoundingClientRect(el) {\n        var a = el.getBoundingClientRect();\n        var b = el.parentNode.getBoundingClientRect();\n        return {\n          left: a.left - b.left,\n          top: a.top - b.top,\n          width: a.width,\n          height: a.height\n        };\n      }\n\n      var rect = getLocalBoundingClientRect(this.element);\n      this.center = {\n        left: Math.round(rect.left + rect.width / 2),\n        top: Math.round(rect.top + rect.height / 2)\n      };\n      Particles_DEBUG && console.log(Particles_LOG, \'center\', this.center);\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      Particles_DEBUG && console.log(Particles_LOG, \'start()\');\n      this.update();\n      var svg = this.appendHtml(this.element.parentElement, "<svg xmlns=\\"http://www.w3.org/2000/svg\\" xmlns:xlink=\\"http://www.w3.org/1999/xlink\\" width=\\"1\\" height=\\"1\\" viewBox=\\"0 0 1 1\\" style=\\"pointer-events: none; position: absolute; overflow: visible;\\"></svg>");\n      svg.style.left = this.center.left + \'px\';\n      svg.style.top = this.center.top + \'px\'; // Generate\n\n      for (var i = 0; i < 5; i++) {\n        var tpl = this.templates[Math.ceil(Math.random() * this.templates.length) - 1];\n        var node = tpl.node.cloneNode();\n        node.setAttribute(\'id\', \'random-\' + Math.round(Math.random() * 10000000000));\n        node.style.display = \'block\';\n        node.style.opacity = 0; // node.style.transform = \'translate(\'+(originX-tpl.width/2)+\'px, \'+(originY-tpl.height/2)+\'px)\';\n\n        node.style.transform = \'translate(-10px, -10px)\';\n        svg.appendChild(node); //gsap.to(node, {duration: 0.2*i, opacity: 1, y: \'-=80\', rotation: 360, transformOrigin: "50% 50%"});\n\n        var tl = gsap.timeline({\n          delay: 0.05 * i\n        }); // tl.timeScale(0.1);\n\n        var x = i % 2 ? -40 * (Math.random() * 2 * this.options.power) : 40 * (Math.random() * 2 * this.options.power);\n        var y = -30 * (i / 2 + 1) * this.options.power;\n        tl.to(node, {\n          duration: 1.4,\n          ease: "power3.out",\n          x: x,\n          y: y,\n          rotation: 130,\n          scale: this.options.scale,\n          transformOrigin: "50% 50%"\n        }, 0);\n        tl.to(node, {\n          duration: 0.2,\n          opacity: 1\n        }, 0);\n        tl.to(node, {\n          duration: 0.3,\n          opacity: 0\n        }, "-=".concat(0.3 * this.options.decay));\n        tl.eventCallback("onComplete", function (node) {\n          var parentNode = node.parentNode;\n          parentNode.removeChild(node);\n\n          if (parentNode.children.length == 0) {\n            parentNode.parentNode.removeChild(parentNode);\n          }\n        }, [node]);\n      }\n    }\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nParticles_defineProperty(Particles_default, "manifest", {\n  id: \'particles\',\n  options: {\n    trigger: \'click\',\n    scale: 2,\n    power: 2,\n    decay: 3\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/experimental/Spritesheet.js\nfunction Spritesheet_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Spritesheet_typeof = function _typeof(obj) { return typeof obj; }; } else { Spritesheet_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Spritesheet_typeof(obj); }\n\nfunction Spritesheet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Spritesheet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Spritesheet_createClass(Constructor, protoProps, staticProps) { if (protoProps) Spritesheet_defineProperties(Constructor.prototype, protoProps); if (staticProps) Spritesheet_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Spritesheet_possibleConstructorReturn(self, call) { if (call && (Spritesheet_typeof(call) === "object" || typeof call === "function")) { return call; } return Spritesheet_assertThisInitialized(self); }\n\nfunction Spritesheet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Spritesheet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Spritesheet_setPrototypeOf(subClass, superClass); }\n\nfunction Spritesheet_setPrototypeOf(o, p) { Spritesheet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Spritesheet_setPrototypeOf(o, p); }\n\nfunction Spritesheet_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Spritesheet_get = Reflect.get; } else { Spritesheet_get = function _get(target, property, receiver) { var base = Spritesheet_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Spritesheet_get(target, property, receiver || target); }\n\nfunction Spritesheet_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Spritesheet_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Spritesheet_getPrototypeOf(o) { Spritesheet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Spritesheet_getPrototypeOf(o); }\n\nfunction Spritesheet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Spritesheet_LOG = \'[ FX : Spritesheet ]\';\nvar Spritesheet_DEBUG = false;\n\nvar Spritesheet_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Spritesheet_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Spritesheet_classCallCheck(this, _default);\n\n    _this = Spritesheet_possibleConstructorReturn(this, Spritesheet_getPrototypeOf(_default).apply(this, arguments));\n\n    Spritesheet_defineProperty(Spritesheet_assertThisInitialized(_this), "tl", void 0);\n\n    Spritesheet_get(Spritesheet_getPrototypeOf(_default.prototype), "init", Spritesheet_assertThisInitialized(_this)).call(Spritesheet_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Spritesheet_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Spritesheet_DEBUG && console.log(Spritesheet_LOG, \'options:\', this.options); // Prepare\n      //#BUG: getBoundingClientRect() is always non-scaled in global space\n      // let bounds = this.element.getBoundingClientRect();\n      // !(this.options.width) && (this.options.width = bounds.width); \n      // !(this.options.height) && (this.options.height = bounds.height);\n      // offsetWidth/offsetHeight seems to work better with scaling\n\n      !this.options.width && (this.options.width = this.element.offsetWidth);\n      !this.options.height && (this.options.height = this.element.offsetHeight); // Remove border \n\n      this.element.style.border = \'none\';\n      this.element.style.backgroundColor = \'transparent\'; // Set background image\n\n      this.element.style.backgroundImage = "url(".concat(this.options.src, ")");\n      this.element.style.backgroundPosition = "0 0";\n      this.element.style.backgroundSize = "".concat(this.options.width * this.options.steps, "px");\n      this.element.style.backgroundRepeat = "no-repeat";\n      this.tl = gsap.timeline({\n        paused: true,\n        repeat: this.options.repeat ? -1 : 0\n      });\n      this.tl.add(gsap.to(this.element, {\n        duration: this.options.duration / 1000,\n        backgroundPositionX: "-".concat(this.options.width * (this.options.steps - 1), "px"),\n        ease: "steps(".concat(this.options.steps - 1, ")")\n      }));\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      this.tl.play(0);\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      this.tl.reverse();\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nSpritesheet_defineProperty(Spritesheet_default, "manifest", {\n  id: \'spritesheet\',\n  options: {\n    trigger: \'click\',\n    // loop: false,\n    duration: 500,\n    width: undefined,\n    height: undefined,\n    steps: undefined,\n    repeat: 0\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/experimental/Jump.js\nfunction Jump_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Jump_typeof = function _typeof(obj) { return typeof obj; }; } else { Jump_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Jump_typeof(obj); }\n\nfunction Jump_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Jump_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Jump_createClass(Constructor, protoProps, staticProps) { if (protoProps) Jump_defineProperties(Constructor.prototype, protoProps); if (staticProps) Jump_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Jump_possibleConstructorReturn(self, call) { if (call && (Jump_typeof(call) === "object" || typeof call === "function")) { return call; } return Jump_assertThisInitialized(self); }\n\nfunction Jump_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Jump_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Jump_setPrototypeOf(subClass, superClass); }\n\nfunction Jump_setPrototypeOf(o, p) { Jump_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Jump_setPrototypeOf(o, p); }\n\nfunction Jump_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Jump_get = Reflect.get; } else { Jump_get = function _get(target, property, receiver) { var base = Jump_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Jump_get(target, property, receiver || target); }\n\nfunction Jump_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Jump_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Jump_getPrototypeOf(o) { Jump_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Jump_getPrototypeOf(o); }\n\nfunction Jump_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Jump_LOG = \'[ FX : Jump ]\';\nvar Jump_DEBUG = false;\n\nvar Jump_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Jump_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Jump_classCallCheck(this, _default);\n\n    _this = Jump_possibleConstructorReturn(this, Jump_getPrototypeOf(_default).apply(this, arguments));\n\n    Jump_defineProperty(Jump_assertThisInitialized(_this), "initial", void 0);\n\n    Jump_get(Jump_getPrototypeOf(_default.prototype), "init", Jump_assertThisInitialized(_this)).call(Jump_assertThisInitialized(_this));\n\n    Jump_get(Jump_getPrototypeOf(_default.prototype), "start", Jump_assertThisInitialized(_this)).call(Jump_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Jump_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Jump_DEBUG && console.log(Jump_LOG, \'init()\', this.options);\n      this.initial = {\n        y: gsap.getProperty(this.element, \'y\')\n      };\n      Jump_DEBUG && console.log(Jump_LOG, \'this.initial\', this.initial);\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      Jump_DEBUG && console.log(Jump_LOG, \'start()\');\n      gsap.to(this.element, {\n        y: this.initial.y - 20,\n        duration: 0.4,\n        ease: \'power.out(4)\'\n      });\n      gsap.to(this.element, {\n        y: this.initial.y,\n        duration: 0.5,\n        delay: 0.5,\n        ease: \'bounce.out(20)\'\n      });\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nJump_defineProperty(Jump_default, "manifest", {\n  id: \'jump\',\n  options: {\n    trigger: \'hover\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/experimental/HandCursor.js\nfunction HandCursor_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { HandCursor_typeof = function _typeof(obj) { return typeof obj; }; } else { HandCursor_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return HandCursor_typeof(obj); }\n\nfunction HandCursor_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction HandCursor_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction HandCursor_createClass(Constructor, protoProps, staticProps) { if (protoProps) HandCursor_defineProperties(Constructor.prototype, protoProps); if (staticProps) HandCursor_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction HandCursor_possibleConstructorReturn(self, call) { if (call && (HandCursor_typeof(call) === "object" || typeof call === "function")) { return call; } return HandCursor_assertThisInitialized(self); }\n\nfunction HandCursor_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction HandCursor_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) HandCursor_setPrototypeOf(subClass, superClass); }\n\nfunction HandCursor_setPrototypeOf(o, p) { HandCursor_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return HandCursor_setPrototypeOf(o, p); }\n\nfunction HandCursor_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { HandCursor_get = Reflect.get; } else { HandCursor_get = function _get(target, property, receiver) { var base = HandCursor_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return HandCursor_get(target, property, receiver || target); }\n\nfunction HandCursor_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = HandCursor_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction HandCursor_getPrototypeOf(o) { HandCursor_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return HandCursor_getPrototypeOf(o); }\n\nfunction HandCursor_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar HandCursor_LOG = \'[ FX : HandCursor ]\';\nvar HandCursor_DEBUG = false;\n\nvar HandCursor_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  HandCursor_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    HandCursor_classCallCheck(this, _default);\n\n    _this = HandCursor_possibleConstructorReturn(this, HandCursor_getPrototypeOf(_default).apply(this, arguments));\n\n    HandCursor_get(HandCursor_getPrototypeOf(_default.prototype), "init", HandCursor_assertThisInitialized(_this)).call(HandCursor_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  HandCursor_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      HandCursor_DEBUG && console.log(HandCursor_LOG, \'init()\', this.options);\n      this.element.style.cursor = \'pointer\';\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n    /**\n     * Generate elements\n     */\n\n  }, {\n    key: "generateElements",\n    value: function generateElements() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nHandCursor_defineProperty(HandCursor_default, "manifest", {\n  id: \'hand-cursor\',\n  options: {\n    trigger: \'load\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/experimental/Debugger.js\nfunction Debugger_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Debugger_typeof = function _typeof(obj) { return typeof obj; }; } else { Debugger_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Debugger_typeof(obj); }\n\nfunction Debugger_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Debugger_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Debugger_createClass(Constructor, protoProps, staticProps) { if (protoProps) Debugger_defineProperties(Constructor.prototype, protoProps); if (staticProps) Debugger_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Debugger_possibleConstructorReturn(self, call) { if (call && (Debugger_typeof(call) === "object" || typeof call === "function")) { return call; } return Debugger_assertThisInitialized(self); }\n\nfunction Debugger_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Debugger_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Debugger_setPrototypeOf(subClass, superClass); }\n\nfunction Debugger_setPrototypeOf(o, p) { Debugger_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Debugger_setPrototypeOf(o, p); }\n\nfunction Debugger_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Debugger_get = Reflect.get; } else { Debugger_get = function _get(target, property, receiver) { var base = Debugger_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Debugger_get(target, property, receiver || target); }\n\nfunction Debugger_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Debugger_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Debugger_getPrototypeOf(o) { Debugger_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Debugger_getPrototypeOf(o); }\n\nfunction Debugger_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Debugger_LOG = \'[ FX : Debugger ]\';\nvar Debugger_DEBUG = true;\n\nvar Debugger_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Debugger_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Debugger_classCallCheck(this, _default);\n\n    _this = Debugger_possibleConstructorReturn(this, Debugger_getPrototypeOf(_default).apply(this, arguments));\n\n    Debugger_get(Debugger_getPrototypeOf(_default.prototype), "init", Debugger_assertThisInitialized(_this)).call(Debugger_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Debugger_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      console.log(\'\\n\\n\');\n\n      function getLocalBoundingClientRect(el) {\n        var a = el.getBoundingClientRect();\n        var b = el.parentNode.getBoundingClientRect();\n        return {\n          left: a.left - b.left,\n          top: a.top - b.top,\n          width: a.width,\n          height: a.height\n        };\n      } // Client Rect\n\n\n      var clientRect = this.element.getBoundingClientRect();\n      console.log(\'clientRect:\', clientRect);\n      var parentClientRect = this.element.parentNode.getBoundingClientRect();\n      console.log(\'parentClientRect:\', parentClientRect);\n      console.log(\'local rect:\', getLocalBoundingClientRect(this.element));\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nDebugger_defineProperty(Debugger_default, "manifest", {\n  id: \'Debugger\',\n  options: {\n    trigger: \'load\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/experimental/Remove.js\nfunction Remove_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Remove_typeof = function _typeof(obj) { return typeof obj; }; } else { Remove_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Remove_typeof(obj); }\n\nfunction Remove_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Remove_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Remove_createClass(Constructor, protoProps, staticProps) { if (protoProps) Remove_defineProperties(Constructor.prototype, protoProps); if (staticProps) Remove_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Remove_possibleConstructorReturn(self, call) { if (call && (Remove_typeof(call) === "object" || typeof call === "function")) { return call; } return Remove_assertThisInitialized(self); }\n\nfunction Remove_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Remove_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Remove_setPrototypeOf(subClass, superClass); }\n\nfunction Remove_setPrototypeOf(o, p) { Remove_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Remove_setPrototypeOf(o, p); }\n\nfunction Remove_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Remove_get = Reflect.get; } else { Remove_get = function _get(target, property, receiver) { var base = Remove_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Remove_get(target, property, receiver || target); }\n\nfunction Remove_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Remove_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Remove_getPrototypeOf(o) { Remove_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Remove_getPrototypeOf(o); }\n\nfunction Remove_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Remove_LOG = \'[ FX : Remove ]\';\nvar Remove_DEBUG = true;\n\nvar Remove_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Remove_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Remove_classCallCheck(this, _default);\n\n    _this = Remove_possibleConstructorReturn(this, Remove_getPrototypeOf(_default).apply(this, arguments));\n\n    Remove_get(Remove_getPrototypeOf(_default.prototype), "init", Remove_assertThisInitialized(_this)).call(Remove_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Remove_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Remove_DEBUG && console.log(Remove_LOG, \'options:\', this.options);\n      this.element.parentElement.removeChild(this.element);\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nRemove_defineProperty(Remove_default, "manifest", {\n  id: \'remove\',\n  options: {\n    trigger: \'load\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/experimental/Fade.js\nfunction Fade_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Fade_typeof = function _typeof(obj) { return typeof obj; }; } else { Fade_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Fade_typeof(obj); }\n\nfunction Fade_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Fade_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Fade_createClass(Constructor, protoProps, staticProps) { if (protoProps) Fade_defineProperties(Constructor.prototype, protoProps); if (staticProps) Fade_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Fade_possibleConstructorReturn(self, call) { if (call && (Fade_typeof(call) === "object" || typeof call === "function")) { return call; } return Fade_assertThisInitialized(self); }\n\nfunction Fade_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Fade_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Fade_setPrototypeOf(subClass, superClass); }\n\nfunction Fade_setPrototypeOf(o, p) { Fade_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Fade_setPrototypeOf(o, p); }\n\nfunction Fade_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Fade_get = Reflect.get; } else { Fade_get = function _get(target, property, receiver) { var base = Fade_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Fade_get(target, property, receiver || target); }\n\nfunction Fade_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Fade_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Fade_getPrototypeOf(o) { Fade_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Fade_getPrototypeOf(o); }\n\nfunction Fade_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Fade_LOG = \'[ FX : Fade ]\';\nvar Fade_DEBUG = true;\n\nvar Fade_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Fade_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Fade_classCallCheck(this, _default);\n\n    _this = Fade_possibleConstructorReturn(this, Fade_getPrototypeOf(_default).apply(this, arguments));\n\n    Fade_get(Fade_getPrototypeOf(_default.prototype), "init", Fade_assertThisInitialized(_this)).call(Fade_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Fade_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Fade_DEBUG && console.log(Fade_LOG, \'init()\', this.options); //this.timeline = gsap.timeline({paused: true});\n\n      gsap.set(this.element, {\n        opacity: 0\n      });\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      Fade_DEBUG && console.log(Fade_LOG, \'start()\');\n      gsap.to(this.element, {\n        delay: this.options.delay / 1000,\n        opacity: 1\n      });\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      Fade_DEBUG && console.log(Fade_LOG, \'end()\');\n      gsap.to(this.element, {\n        delay: this.options.delay / 1000,\n        opacity: 0\n      });\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nFade_defineProperty(Fade_default, "manifest", {\n  id: \'fade\',\n  options: {\n    trigger: \'load\',\n    delay: 100\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/experimental/PanZoom.js\nfunction PanZoom_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { PanZoom_typeof = function _typeof(obj) { return typeof obj; }; } else { PanZoom_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return PanZoom_typeof(obj); }\n\nfunction PanZoom_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction PanZoom_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PanZoom_createClass(Constructor, protoProps, staticProps) { if (protoProps) PanZoom_defineProperties(Constructor.prototype, protoProps); if (staticProps) PanZoom_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction PanZoom_possibleConstructorReturn(self, call) { if (call && (PanZoom_typeof(call) === "object" || typeof call === "function")) { return call; } return PanZoom_assertThisInitialized(self); }\n\nfunction PanZoom_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction PanZoom_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) PanZoom_setPrototypeOf(subClass, superClass); }\n\nfunction PanZoom_setPrototypeOf(o, p) { PanZoom_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return PanZoom_setPrototypeOf(o, p); }\n\nfunction PanZoom_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { PanZoom_get = Reflect.get; } else { PanZoom_get = function _get(target, property, receiver) { var base = PanZoom_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return PanZoom_get(target, property, receiver || target); }\n\nfunction PanZoom_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = PanZoom_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction PanZoom_getPrototypeOf(o) { PanZoom_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return PanZoom_getPrototypeOf(o); }\n\nfunction PanZoom_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar PanZoom_LOG = \'[ FX : PanZoom ]\';\nvar PanZoom_DEBUG = true;\n\nvar PanZoom_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  PanZoom_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    PanZoom_classCallCheck(this, _default);\n\n    _this = PanZoom_possibleConstructorReturn(this, PanZoom_getPrototypeOf(_default).apply(this, arguments));\n\n    PanZoom_get(PanZoom_getPrototypeOf(_default.prototype), "init", PanZoom_assertThisInitialized(_this)).call(PanZoom_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  PanZoom_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      console.log(PanZoom_LOG, \'options:\', this.options); // TEMP: XD HACK\n\n      this.element.parentNode.style.overflow = \'hidden\'; // Get stops\n\n      var stopElements = this.element.querySelectorAll(\'[hero-fx-panzoom-stop]\');\n      PanZoom_DEBUG && console.log(PanZoom_LOG, \'stopElements:\', stopElements); // Process stops\n\n      this.stops = [];\n      stopElements.forEach(function (item) {\n        var options = item.getAttribute(\'hero-fx-panzoom-stop\');\n        options = hero.fx.FxScanner.extractOptions(options);\n        options = Object.assign({\n          delay: _this2.options.stopDelay\n        }, options);\n        var stop = {\n          el: item,\n          scale: _this2.element.offsetWidth / item.offsetWidth,\n          left: parseInt(window.getComputedStyle(item).transform.split(\'(\')[1].split(\',\')[4]),\n          top: parseInt(window.getComputedStyle(item).transform.split(\'(\')[1].split(\',\')[5]),\n          options: options\n        };\n\n        _this2.stops.push(stop);\n\n        item.style.opacity = 0;\n        item.style.pointerEvents = \'none\';\n      });\n      PanZoom_DEBUG && console.log(PanZoom_LOG, \'stops:\', this.stops); // Timeline\n\n      this.timeline = gsap.timeline({\n        paused: true\n      });\n      this.stops.forEach(function (item, index) {\n        _this2.timeline.to(_this2.element, {\n          scale: item.scale,\n          x: -item.left * item.scale,\n          y: -item.top * item.scale,\n          transformOrigin: \'0 0\',\n          delay: index > 0 && _this2.stops[index - 1].options.stop ? 0 : item.options.delay / 1000,\n          duration: 1.8,\n          ease: \'power4.inOut\',\n          // #PERFORMANCE-AND-BLURINESS \n          // Should be false to prevent blurriness on scales specially on mobile (e.g. iPhone)\n          // force3D: true,\n          force3D: false // onComplete() {\n          //   gsap.set( this.targets()[0], {\n          //     force3D: false\n          //   });\n          // }\n\n        });\n\n        item.options.stop && _this2.timeline.add(function () {\n          _this2.timeline.pause();\n\n          _this2.element.addEventListener(\'click\', function () {\n            _this2.timeline.play();\n          }, {\n            once: true\n          });\n        });\n      });\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      this.timeline.play();\n    }\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nPanZoom_defineProperty(PanZoom_default, "manifest", {\n  id: \'panzoom\',\n  options: {\n    trigger: \'load\',\n    // delay: 1000,\n    stopDelay: 2000\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/components/YouTube.js\nfunction YouTube_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { YouTube_typeof = function _typeof(obj) { return typeof obj; }; } else { YouTube_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return YouTube_typeof(obj); }\n\nfunction YouTube_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction YouTube_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction YouTube_createClass(Constructor, protoProps, staticProps) { if (protoProps) YouTube_defineProperties(Constructor.prototype, protoProps); if (staticProps) YouTube_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction YouTube_possibleConstructorReturn(self, call) { if (call && (YouTube_typeof(call) === "object" || typeof call === "function")) { return call; } return YouTube_assertThisInitialized(self); }\n\nfunction YouTube_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction YouTube_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) YouTube_setPrototypeOf(subClass, superClass); }\n\nfunction YouTube_setPrototypeOf(o, p) { YouTube_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return YouTube_setPrototypeOf(o, p); }\n\nfunction YouTube_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { YouTube_get = Reflect.get; } else { YouTube_get = function _get(target, property, receiver) { var base = YouTube_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return YouTube_get(target, property, receiver || target); }\n\nfunction YouTube_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = YouTube_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction YouTube_getPrototypeOf(o) { YouTube_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return YouTube_getPrototypeOf(o); }\n\nfunction YouTube_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar YouTube_LOG = \'[ FX : YouTube ]\';\nvar YouTube_DEBUG = true;\n\nvar YouTube_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  YouTube_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    YouTube_classCallCheck(this, _default);\n\n    _this = YouTube_possibleConstructorReturn(this, YouTube_getPrototypeOf(_default).apply(this, arguments));\n\n    YouTube_get(YouTube_getPrototypeOf(_default.prototype), "init", YouTube_assertThisInitialized(_this)).call(YouTube_assertThisInitialized(_this));\n\n    return _this;\n  } // TEMP: Use FusionHelper instead\n  // TEMP: Use FusionHelper instead\n\n\n  YouTube_createClass(_default, [{\n    key: "appendHtml",\n    value: function appendHtml(target, markup) {\n      target.insertAdjacentHTML(\'beforeend\', markup);\n      return target.lastChild;\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      this.element.style.backgroundColor = \'transparent\';\n      this.element.style.border = \'none\';\n    }\n  }, {\n    key: "update",\n    value: function update() {// DEBUG && console.log(LOG, \'update()\');\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      this.appendHtml(this.element, "\\n      <div style=\\"position: relative; padding-top: ".concat(1080 / 1920 * 100, "%\\">\\n        <iframe width=\\"100%\\" height=\\"100%\\" src=\\"https://www.youtube.com/embed/").concat(this.options.videoId, "?").concat(this.options.autoplay ? \'autoplay=1\' : \'\', "\\" frameborder=\\"0\\"  allow=\\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\\" allowfullscreen\\n                style=\\"position: absolute; top: 0; right: 0; bottom: 0; left: 0;\\"></iframe>\\n      </div>"));\n    }\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nYouTube_defineProperty(YouTube_default, "manifest", {\n  id: \'youtube\',\n  options: {\n    trigger: \'load\',\n    videoId: \'C0DPdy98e4c\',\n    autoplay: true\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/components/IFrame.js\nfunction IFrame_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { IFrame_typeof = function _typeof(obj) { return typeof obj; }; } else { IFrame_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return IFrame_typeof(obj); }\n\nfunction IFrame_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction IFrame_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction IFrame_createClass(Constructor, protoProps, staticProps) { if (protoProps) IFrame_defineProperties(Constructor.prototype, protoProps); if (staticProps) IFrame_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction IFrame_possibleConstructorReturn(self, call) { if (call && (IFrame_typeof(call) === "object" || typeof call === "function")) { return call; } return IFrame_assertThisInitialized(self); }\n\nfunction IFrame_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction IFrame_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) IFrame_setPrototypeOf(subClass, superClass); }\n\nfunction IFrame_setPrototypeOf(o, p) { IFrame_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return IFrame_setPrototypeOf(o, p); }\n\nfunction IFrame_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { IFrame_get = Reflect.get; } else { IFrame_get = function _get(target, property, receiver) { var base = IFrame_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return IFrame_get(target, property, receiver || target); }\n\nfunction IFrame_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = IFrame_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction IFrame_getPrototypeOf(o) { IFrame_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return IFrame_getPrototypeOf(o); }\n\nfunction IFrame_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar IFrame_LOG = \'[ FX : iframe ]\';\nvar IFrame_DEBUG = true;\n\nvar IFrame_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  IFrame_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    IFrame_classCallCheck(this, _default);\n\n    _this = IFrame_possibleConstructorReturn(this, IFrame_getPrototypeOf(_default).apply(this, arguments));\n\n    IFrame_get(IFrame_getPrototypeOf(_default.prototype), "init", IFrame_assertThisInitialized(_this)).call(IFrame_assertThisInitialized(_this));\n\n    return _this;\n  } // TEMP: Use FusionHelper instead\n  // TEMP: Use FusionHelper instead\n\n\n  IFrame_createClass(_default, [{\n    key: "appendHtml",\n    value: function appendHtml(target, markup) {\n      target.insertAdjacentHTML(\'beforeend\', markup);\n      return target.lastChild;\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      IFrame_DEBUG && console.log(IFrame_LOG, \'init()\', this.options);\n    }\n  }, {\n    key: "update",\n    value: function update() {// DEBUG && console.log(LOG, \'update()\');\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      this.appendHtml(this.element, "\\n      <div style=\\"position: relative; padding-top: ".concat(1080 / 1920 * 100, "%\\">\\n        <iframe width=\\"100%\\" height=\\"100%\\" src=\\"").concat(this.options.src, "\\" frameborder=\\"0\\"\\n                style=\\"position: absolute; top: 0; right: 0; bottom: 0; left: 0;\\"></iframe>\\n      </div>"));\n    }\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nIFrame_defineProperty(IFrame_default, "manifest", {\n  id: \'iframe\',\n  options: {\n    trigger: \'load\',\n    src: \'https://xdhero.com/\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/components/Lottie.js\nfunction Lottie_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Lottie_typeof = function _typeof(obj) { return typeof obj; }; } else { Lottie_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Lottie_typeof(obj); }\n\nfunction Lottie_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Lottie_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Lottie_createClass(Constructor, protoProps, staticProps) { if (protoProps) Lottie_defineProperties(Constructor.prototype, protoProps); if (staticProps) Lottie_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Lottie_possibleConstructorReturn(self, call) { if (call && (Lottie_typeof(call) === "object" || typeof call === "function")) { return call; } return Lottie_assertThisInitialized(self); }\n\nfunction Lottie_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Lottie_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Lottie_setPrototypeOf(subClass, superClass); }\n\nfunction Lottie_setPrototypeOf(o, p) { Lottie_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Lottie_setPrototypeOf(o, p); }\n\nfunction Lottie_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Lottie_get = Reflect.get; } else { Lottie_get = function _get(target, property, receiver) { var base = Lottie_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Lottie_get(target, property, receiver || target); }\n\nfunction Lottie_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Lottie_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Lottie_getPrototypeOf(o) { Lottie_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Lottie_getPrototypeOf(o); }\n\nfunction Lottie_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Lottie_LOG = \'[ FX : Lottie ]\';\nvar Lottie_DEBUG = true;\n\nvar Lottie_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Lottie_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Lottie_classCallCheck(this, _default);\n\n    _this = Lottie_possibleConstructorReturn(this, Lottie_getPrototypeOf(_default).apply(this, arguments));\n\n    Lottie_get(Lottie_getPrototypeOf(_default.prototype), "init", Lottie_assertThisInitialized(_this)).call(Lottie_assertThisInitialized(_this));\n\n    return _this;\n  } // TEMP: Use FusionHelper instead\n  // TEMP: Use FusionHelper instead\n\n\n  Lottie_createClass(_default, [{\n    key: "appendHtml",\n    value: function appendHtml(target, markup) {\n      target.insertAdjacentHTML(\'beforeend\', markup);\n      return target.lastChild;\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      var script = document.createElement(\'script\');\n      script.setAttribute(\'src\', \'https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js\');\n      document.head.appendChild(script);\n    }\n  }, {\n    key: "update",\n    value: function update() {// DEBUG && console.log(LOG, \'update()\');\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      console.log(Lottie_LOG, \'START\');\n      this.appendHtml(this.element, "\\n    <lottie-player src=\\"".concat(this.options.url, "\\"  background=\\"transparent\\"  speed=\\"1\\"  style=\\"width: 100%; height: 100%;\\" loop autoplay ></lottie-player>\\n    "));\n      console.log(Lottie_LOG, \'START DONE\');\n    }\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nLottie_defineProperty(Lottie_default, "manifest", {\n  id: \'lottie\',\n  options: {\n    trigger: \'load\',\n    url: \'https://assets2.lottiefiles.com/packages/lf20_6aYlBl.json\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/core/Fit.js\nfunction Fit_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Fit_typeof = function _typeof(obj) { return typeof obj; }; } else { Fit_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Fit_typeof(obj); }\n\nfunction Fit_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Fit_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Fit_createClass(Constructor, protoProps, staticProps) { if (protoProps) Fit_defineProperties(Constructor.prototype, protoProps); if (staticProps) Fit_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Fit_possibleConstructorReturn(self, call) { if (call && (Fit_typeof(call) === "object" || typeof call === "function")) { return call; } return Fit_assertThisInitialized(self); }\n\nfunction Fit_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Fit_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Fit_setPrototypeOf(subClass, superClass); }\n\nfunction Fit_setPrototypeOf(o, p) { Fit_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Fit_setPrototypeOf(o, p); }\n\nfunction Fit_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Fit_get = Reflect.get; } else { Fit_get = function _get(target, property, receiver) { var base = Fit_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Fit_get(target, property, receiver || target); }\n\nfunction Fit_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Fit_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Fit_getPrototypeOf(o) { Fit_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Fit_getPrototypeOf(o); }\n\nfunction Fit_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nvar Fit_LOG = \'[ FX : Fit ]\';\nvar Fit_DEBUG = true;\n\nvar Fit_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Fit_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Fit_classCallCheck(this, _default);\n\n    _this = Fit_possibleConstructorReturn(this, Fit_getPrototypeOf(_default).apply(this, arguments));\n\n    Fit_get(Fit_getPrototypeOf(_default.prototype), "init", Fit_assertThisInitialized(_this)).call(Fit_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Fit_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      console.log(Fit_LOG, \'init()\');\n\n      if (!this.options.width) {\n        // const display = this.element.style.display;\n        // this.element.style.display = \'none\';\n        this.options.width = this.element.getBoundingClientRect().width;\n        this.options.height = this.element.getBoundingClientRect().height;\n        console.log(Fit_LOG, \'init()\', \'width/height: \', this.options.width, this.options.height); // this.element.style.display = display;\n      }\n\n      window.addEventListener(\'resize\', hero.helper.throttle(this.updateLayout.bind(this), 200));\n      window.addEventListener(\'resize\', hero.helper.debounce(this.updateLayout.bind(this), 2000));\n      this.updateLayout();\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }, {\n    key: "updateLayout",\n    value: function updateLayout() {\n      // if (this.element.style.display == \'none\') return;\n      // const bbox = this.element.parentElement.getBoundingClientRect();\n      // const availWidth = bbox.width;\n      // const availHeight = bbox.height;\n      // console.log(LOG, \'availWidth\', availWidth);\n      // console.log(LOG, \'availHeight\', availHeight);\n      // let scaleX = availWidth / this.options.width;\n      // let scaleY = availHeight / this.options.height;\n      // let scale = Math.min(scaleX, scaleY);\n      // console.log(LOG, \'scale\', scale);\n      // scale = (scale > 1) ? 1 : scale;\n      // this.element.style.transform = `scale(${scale})`;\n      if (this.element.style.display == \'none\') return;\n      var availWidth = this.element.parentElement.clientWidth;\n      var availHeight = this.element.parentElement.clientHeight;\n      console.log(Fit_LOG, \'availWidth\', availWidth);\n      console.log(Fit_LOG, \'availHeight\', availHeight);\n      var scaleX = availWidth / this.options.width;\n      var scaleY = availHeight / this.options.height;\n      var scale = Math.min(scaleX, scaleY);\n      console.log(Fit_LOG, \'scale\', scale);\n      scale = scale > 1 ? 1 : scale; // this.element.style.transformOrigin = `0 0`;\n\n      this.element.style.transform = "scale(".concat(scale, ")");\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nFit_defineProperty(Fit_default, "manifest", {\n  id: \'fit\',\n  options: {\n    trigger: \'load\',\n    width: null,\n    // raw width\n    height: null // raw height\n\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/experimental_data_driven/TextInput.js\nfunction TextInput_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { TextInput_typeof = function _typeof(obj) { return typeof obj; }; } else { TextInput_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return TextInput_typeof(obj); }\n\nfunction TextInput_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TextInput_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TextInput_createClass(Constructor, protoProps, staticProps) { if (protoProps) TextInput_defineProperties(Constructor.prototype, protoProps); if (staticProps) TextInput_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction TextInput_possibleConstructorReturn(self, call) { if (call && (TextInput_typeof(call) === "object" || typeof call === "function")) { return call; } return TextInput_assertThisInitialized(self); }\n\nfunction TextInput_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TextInput_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) TextInput_setPrototypeOf(subClass, superClass); }\n\nfunction TextInput_setPrototypeOf(o, p) { TextInput_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TextInput_setPrototypeOf(o, p); }\n\nfunction TextInput_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { TextInput_get = Reflect.get; } else { TextInput_get = function _get(target, property, receiver) { var base = TextInput_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return TextInput_get(target, property, receiver || target); }\n\nfunction TextInput_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = TextInput_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction TextInput_getPrototypeOf(o) { TextInput_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TextInput_getPrototypeOf(o); }\n\nfunction TextInput_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar TextInput_LOG = \'[ FX : text-input ]\';\nvar TextInput_DEBUG = false;\n\nvar TextInput_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  TextInput_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    TextInput_classCallCheck(this, _default);\n\n    _this = TextInput_possibleConstructorReturn(this, TextInput_getPrototypeOf(_default).apply(this, arguments));\n\n    TextInput_defineProperty(TextInput_assertThisInitialized(_this), "input", void 0);\n\n    TextInput_get(TextInput_getPrototypeOf(_default.prototype), "init", TextInput_assertThisInitialized(_this)).call(TextInput_assertThisInitialized(_this));\n\n    return _this;\n  } // TEMP: Use FusionHelper instead\n  // TEMP: Use FusionHelper instead\n\n\n  TextInput_createClass(_default, [{\n    key: "appendHtml",\n    value: function appendHtml(target, markup) {\n      target.insertAdjacentHTML(\'beforeend\', markup);\n      return target.lastChild;\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      TextInput_DEBUG && console.log(TextInput_LOG, \'init()\', this.options);\n      var input = \'<input style="position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 100%; outline: none; border: none; padding: 4px 14px; background-color: transparent;"/>\';\n      this.appendHtml(this.element, input);\n      this.input = this.element.querySelector(\'input\');\n\n      if (this.options.source) {\n        player.data.on(\'change\', function (key, value) {\n          if (key === _this2.options.source) {\n            _this2.input.value = value;\n          }\n        });\n        this.input.addEventListener(\'keyup\', function (evt) {\n          player.data.set(_this2.options.source, evt.currentTarget.value);\n        });\n      }\n\n      this.input.addEventListener(\'keyup\', function (evt) {\n        _this2.element.dispatchEvent(new CustomEvent(\'type\', {\n          detail: {\n            value: evt.currentTarget.value\n          }\n        }));\n      });\n    }\n  }, {\n    key: "update",\n    value: function update() {}\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nTextInput_defineProperty(TextInput_default, "manifest", {\n  id: \'text-input\',\n  options: {\n    trigger: \'load\',\n    source: \'\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/hero/fx/experimental_data_driven/RepeatGrid.js\nfunction RepeatGrid_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { RepeatGrid_typeof = function _typeof(obj) { return typeof obj; }; } else { RepeatGrid_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return RepeatGrid_typeof(obj); }\n\nfunction RepeatGrid_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction RepeatGrid_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction RepeatGrid_createClass(Constructor, protoProps, staticProps) { if (protoProps) RepeatGrid_defineProperties(Constructor.prototype, protoProps); if (staticProps) RepeatGrid_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction RepeatGrid_possibleConstructorReturn(self, call) { if (call && (RepeatGrid_typeof(call) === "object" || typeof call === "function")) { return call; } return RepeatGrid_assertThisInitialized(self); }\n\nfunction RepeatGrid_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction RepeatGrid_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) RepeatGrid_setPrototypeOf(subClass, superClass); }\n\nfunction RepeatGrid_setPrototypeOf(o, p) { RepeatGrid_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return RepeatGrid_setPrototypeOf(o, p); }\n\nfunction RepeatGrid_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { RepeatGrid_get = Reflect.get; } else { RepeatGrid_get = function _get(target, property, receiver) { var base = RepeatGrid_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return RepeatGrid_get(target, property, receiver || target); }\n\nfunction RepeatGrid_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = RepeatGrid_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction RepeatGrid_getPrototypeOf(o) { RepeatGrid_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return RepeatGrid_getPrototypeOf(o); }\n\nfunction RepeatGrid_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar RepeatGrid_LOG = \'[ FX : repeat-grid ]\';\nvar RepeatGrid_DEBUG = false;\n\nvar RepeatGrid_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  RepeatGrid_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    RepeatGrid_classCallCheck(this, _default);\n\n    _this = RepeatGrid_possibleConstructorReturn(this, RepeatGrid_getPrototypeOf(_default).apply(this, arguments));\n\n    RepeatGrid_defineProperty(RepeatGrid_assertThisInitialized(_this), "input", void 0);\n\n    RepeatGrid_get(RepeatGrid_getPrototypeOf(_default.prototype), "init", RepeatGrid_assertThisInitialized(_this)).call(RepeatGrid_assertThisInitialized(_this));\n\n    return _this;\n  } // TEMP: Use FusionHelper instead\n  // TEMP: Use FusionHelper instead\n\n\n  RepeatGrid_createClass(_default, [{\n    key: "appendHtml",\n    value: function appendHtml(target, markup) {\n      target.insertAdjacentHTML(\'beforeend\', markup);\n      return target.lastChild;\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      RepeatGrid_DEBUG && console.log(RepeatGrid_LOG, \'init()\', this.options); //---\n      // Custom CSS\n\n      var css = "\\n      .repeat-grid > * {\\n        position: static !important;\\n      }";\n      var style = document.createElement(\'style\');\n      document.head.appendChild(style);\n      style.appendChild(document.createTextNode(css)); //---\n      // Extract grid meta data from XD\n\n      var gridMetaData = JSON.parse(decodeURIComponent(this.element.getAttribute(\'xd-repeat-grid\')));\n      RepeatGrid_DEBUG && console.log(RepeatGrid_LOG, \'REPEAT_GRID_DATA:\', gridMetaData); //---\n      // Prepare grid\n\n      this.element.classList.add(\'repeat-grid\');\n      this.element.style.width = gridMetaData.width + \'px\';\n      this.element.style.height = gridMetaData.numRows * (gridMetaData.cellHeight + gridMetaData.paddingY) + \'px\';\n      this.element.style.overflowX = \'hidden\';\n      this.element.style.overflowY = \'auto\'; // this.element.style.border = \'1px solid #DDD\';\n      //---\n      // Extract template and remove all items\n\n      var first = $(this.element).find(\'.item\').first();\n      first[0].style.width = gridMetaData.cellWidth + \'px\';\n      first[0].style.height = gridMetaData.cellHeight + \'px\';\n      first[0].style.marginBottom = gridMetaData.paddingY + \'px\';\n      first[0].style.transform = \'translate(\' + -gridMetaData.offsetX + \'px, \' + -gridMetaData.offsetY + \'px)\'; //---\n      // Populate\n\n      var populate = function populate(value) {\n        RepeatGrid_DEBUG && console.log(RepeatGrid_LOG, \'populate\', value);\n        $(_this2.element).find(\'.item\').remove();\n        value.forEach(function (record, index) {\n          var element = first.clone(); //element[0].style.border = \'2px solid blue\';\n          // Following stunt is needed because offset of elements (without stunt user might click on a different element)\n\n          element[0].style.pointerEvents = \'none\';\n          element[0].style.opacity = 0;\n          element.find(\'*\').css({\n            pointerEvents: \'all\'\n          }); // element.find(\'svg.country text tspan\')[0].textContent = item.country;\n          // element.find(\'svg.city text tspan\')[0].textContent = item.city;\n          // var image = element.find(\'.image\')[0];\n          //image.style.backgroundImage = \'url(\'+item.image+\')\';\n          //image.style.backgroundSize = \'contain\';\n          // image.setAttribute(\'src\', item.image)\n          // element.find(\'.special\')[0].style.display = item.special ? \'block\' : \'none\';\n          // Save data on item element\n\n          element[0].data = record; // element[0].addEventListener(\'click\', function(evt) {\n          //   window.data.current = evt.currentTarget.tmpData;\n          //   player.loadScene(\'detail\');\n          //   window.data.updateDetail();\n          // });\n\n          for (var key in record) {\n            if (record.hasOwnProperty(key)) {\n              var _value = record[key]; // console.log(key, \' => \', value);\n\n              var placeholder = element[0].querySelector(\'.\' + key);\n\n              if (placeholder) {\n                // Placeholder is image\n                if (placeholder.nodeName == \'IMG\') {\n                  placeholder.src = _value;\n                } // Placeholder is text\n                else {\n                    // placeholder.querySelector(\'text tspan\').textContent = value;\n                    placeholder.innerText = _value;\n                  }\n              }\n            }\n          }\n\n          gsap.to(element[0], {\n            opacity: 1,\n            delay: index * 0.1,\n            duration: 0.6\n          });\n          $(_this2.element).append(element);\n          hero.fx.FxScanner.scan(_this2.element);\n        });\n      }; //---\n      // Get data\n\n\n      if (this.options.source) {\n        player.data.on(\'change\', function (key, value) {\n          if (key === _this2.options.source) {\n            // this.input.value = value;\n            populate(value);\n          }\n        });\n      }\n    }\n  }, {\n    key: "update",\n    value: function update() {}\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nRepeatGrid_defineProperty(RepeatGrid_default, "manifest", {\n  id: \'repeat-grid\',\n  options: {\n    trigger: \'load\',\n    source: \'\'\n  }\n});\n\n\n// EXTERNAL MODULE: ./libs/nanoevents.js\nvar nanoevents = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./src/fusion/plugins/PluginBase.js\nfunction PluginBase_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { PluginBase_typeof = function _typeof(obj) { return typeof obj; }; } else { PluginBase_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return PluginBase_typeof(obj); }\n\nfunction PluginBase_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction PluginBase_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PluginBase_createClass(Constructor, protoProps, staticProps) { if (protoProps) PluginBase_defineProperties(Constructor.prototype, protoProps); if (staticProps) PluginBase_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction PluginBase_possibleConstructorReturn(self, call) { if (call && (PluginBase_typeof(call) === "object" || typeof call === "function")) { return call; } return PluginBase_assertThisInitialized(self); }\n\nfunction PluginBase_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction PluginBase_getPrototypeOf(o) { PluginBase_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return PluginBase_getPrototypeOf(o); }\n\nfunction PluginBase_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) PluginBase_setPrototypeOf(subClass, superClass); }\n\nfunction PluginBase_setPrototypeOf(o, p) { PluginBase_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return PluginBase_setPrototypeOf(o, p); }\n\n\nvar PluginBase_LOG = \'[ PluginBase ]\';\nvar PluginBase_DEBUG = true;\n\nvar PluginBase_default =\n/*#__PURE__*/\nfunction (_NanoEvents) {\n  PluginBase_inherits(_default, _NanoEvents);\n\n  function _default(scene, options) {\n    var _this;\n\n    PluginBase_classCallCheck(this, _default);\n\n    _this = PluginBase_possibleConstructorReturn(this, PluginBase_getPrototypeOf(_default).call(this));\n    _this.scene = scene;\n    _this.player = scene.player;\n    _this.options = options;\n    return _this;\n  }\n\n  PluginBase_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      this.options = Object.assign(this.manifest.options, this.options);\n      this.init();\n    }\n  }]);\n\n  return _default;\n}(nanoevents["a" /* default */]);\n\n\n// EXTERNAL MODULE: ./src/fusion/Const.js\nvar Const = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/fusion/plugins/wip/VisualDebugger.js\nfunction VisualDebugger_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { VisualDebugger_typeof = function _typeof(obj) { return typeof obj; }; } else { VisualDebugger_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return VisualDebugger_typeof(obj); }\n\nfunction VisualDebugger_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction VisualDebugger_possibleConstructorReturn(self, call) { if (call && (VisualDebugger_typeof(call) === "object" || typeof call === "function")) { return call; } return VisualDebugger_assertThisInitialized(self); }\n\nfunction VisualDebugger_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction VisualDebugger_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction VisualDebugger_createClass(Constructor, protoProps, staticProps) { if (protoProps) VisualDebugger_defineProperties(Constructor.prototype, protoProps); if (staticProps) VisualDebugger_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction VisualDebugger_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) VisualDebugger_setPrototypeOf(subClass, superClass); }\n\nfunction VisualDebugger_setPrototypeOf(o, p) { VisualDebugger_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return VisualDebugger_setPrototypeOf(o, p); }\n\nfunction VisualDebugger_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { VisualDebugger_get = Reflect.get; } else { VisualDebugger_get = function _get(target, property, receiver) { var base = VisualDebugger_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return VisualDebugger_get(target, property, receiver || target); }\n\nfunction VisualDebugger_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = VisualDebugger_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction VisualDebugger_getPrototypeOf(o) { VisualDebugger_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return VisualDebugger_getPrototypeOf(o); }\n\n// Experimental Plugin\n\n\nvar VisualDebugger_LOG = \'[ Plugin : VisualDebugger ]\';\nvar VisualDebugger_DEBUG = false;\n\nvar VisualDebugger_default =\n/*#__PURE__*/\nfunction (_PluginBase) {\n  VisualDebugger_inherits(_default, _PluginBase);\n\n  VisualDebugger_createClass(_default, null, [{\n    key: "manifest",\n    value: function manifest() {\n      return {\n        id: \'visualDebugger\',\n        options: {}\n      };\n    }\n  }]);\n\n  function _default() {\n    var _this;\n\n    VisualDebugger_classCallCheck(this, _default);\n\n    _this = VisualDebugger_possibleConstructorReturn(this, VisualDebugger_getPrototypeOf(_default).apply(this, arguments));\n    _this.manifest = _this.constructor.manifest();\n\n    VisualDebugger_get(VisualDebugger_getPrototypeOf(_default.prototype), "init", VisualDebugger_assertThisInitialized(_this)).call(VisualDebugger_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  VisualDebugger_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      VisualDebugger_DEBUG && console.log(VisualDebugger_LOG, \'init()\');\n      this.scene.on(Const["a" /* default */].SCENE_PRE_READY, this.on_scene_preReady.bind(this));\n      this.scene.on(Const["a" /* default */].SCENE_READY, this.on_scene_ready.bind(this));\n    }\n    /**\n     * on_scene_preReady\n     */\n\n  }, {\n    key: "on_scene_preReady",\n    value: function on_scene_preReady() {}\n    /**\n     * on_scene_ready\n     */\n\n  }, {\n    key: "on_scene_ready",\n    value: function on_scene_ready() {\n      var clone = this.scene.content.cloneNode(false);\n      clone.setAttribute(\'style\', this.scene.content.getAttribute(\'style\'));\n      clone.style.border = \'1px solid rgba(0,0,0,.2)\';\n      clone.style.boxSizing = \'border-box\';\n      clone.style.pointerEvents = \'none\';\n      this.scene.content.parentNode.appendChild(clone);\n    }\n  }]);\n\n  return _default;\n}(PluginBase_default);\n\n\n// CONCATENATED MODULE: ./src/fusion/plugins/wip/Panorama.js\nfunction Panorama_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Panorama_typeof = function _typeof(obj) { return typeof obj; }; } else { Panorama_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Panorama_typeof(obj); }\n\nfunction Panorama_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Panorama_possibleConstructorReturn(self, call) { if (call && (Panorama_typeof(call) === "object" || typeof call === "function")) { return call; } return Panorama_assertThisInitialized(self); }\n\nfunction Panorama_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Panorama_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Panorama_createClass(Constructor, protoProps, staticProps) { if (protoProps) Panorama_defineProperties(Constructor.prototype, protoProps); if (staticProps) Panorama_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Panorama_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Panorama_setPrototypeOf(subClass, superClass); }\n\nfunction Panorama_setPrototypeOf(o, p) { Panorama_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Panorama_setPrototypeOf(o, p); }\n\nfunction Panorama_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Panorama_get = Reflect.get; } else { Panorama_get = function _get(target, property, receiver) { var base = Panorama_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Panorama_get(target, property, receiver || target); }\n\nfunction Panorama_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Panorama_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Panorama_getPrototypeOf(o) { Panorama_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Panorama_getPrototypeOf(o); }\n\n// Experimental Plugin\n\n\nvar Panorama_LOG = \'[ Plugin : Panorama ]\';\nvar Panorama_DEBUG = true;\n\nvar Panorama_default =\n/*#__PURE__*/\nfunction (_PluginBase) {\n  Panorama_inherits(_default, _PluginBase);\n\n  Panorama_createClass(_default, null, [{\n    key: "manifest",\n    value: function manifest() {\n      return {\n        id: \'panorama\',\n        options: {\n          speed: 1\n        }\n      };\n    }\n  }]);\n\n  function _default() {\n    var _this;\n\n    Panorama_classCallCheck(this, _default);\n\n    _this = Panorama_possibleConstructorReturn(this, Panorama_getPrototypeOf(_default).apply(this, arguments));\n    _this.manifest = _this.constructor.manifest();\n\n    Panorama_get(Panorama_getPrototypeOf(_default.prototype), "init", Panorama_assertThisInitialized(_this)).call(Panorama_assertThisInitialized(_this));\n\n    _this.mouseX;\n    _this.lastScrollTo = 0;\n    return _this;\n  }\n\n  Panorama_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Panorama_DEBUG && console.log(Panorama_LOG, \'init()\');\n      this.scene.on(Const["a" /* default */].SCENE_PRE_READY, this.on_scene_preReady.bind(this));\n      this.scene.on(Const["a" /* default */].SCENE_READY, this.on_scene_ready.bind(this));\n    }\n    /**\n     * on_scene_preReady\n     */\n\n  }, {\n    key: "on_scene_preReady",\n    value: function on_scene_preReady() {\n      // Prepare scene\n      this.scene.element.style.overflowX = \'scroll\';\n      this.scene.content.style.overflow = \'unset\'; // // Tweak content container to get real width\n      // // scene.content.style.width = \'auto\';\n      // scene.content.style.right = \'unset\';\n      // // Prevent history back when scrolling to left on viewport\n      // // #TODO: Not preventing in Edge\n      // scene.element.addEventListener(\'mousewheel\', function(evt) {\n      //   if (evt.currentTarget.scrollLeft <= 0 && evt.deltaX < 0)  evt.preventDefault();\n      // }, {passive: false});\n      // #TODO: DECIDE ON THROTTLE\n\n      this.scene.element.addEventListener(\'mousemove\', hero.FusionHelper.throttle(this.on_scene_mouseMove.bind(this), 50)); // 20fps\n\n      this.scene.element.addEventListener(\'click\', this.on_scene_click.bind(this));\n    }\n    /**\n     * on_scene_ready\n     */\n\n  }, {\n    key: "on_scene_ready",\n    value: function on_scene_ready() {\n      Panorama_DEBUG && console.log(Panorama_LOG, \'on_scene_ready()\');\n    }\n    /**\n     * on_scene_mouseMove\n     */\n\n  }, {\n    key: "on_scene_mouseMove",\n    value: function on_scene_mouseMove(evt) {\n      this.mouseX = evt.clientX - this.scene.element.getBoundingClientRect().left;\n    }\n    /**\n     * on_scene_click\n     */\n\n  }, {\n    key: "on_scene_click",\n    value: function on_scene_click(evt) {\n      // Bail if mouse is on interactive elements\n      if (evt.target.hasAttribute(\'hero-interactive\')) return; // Bail if already moving/scrolling\n\n      if (gsap.isTweening(this.scene.element)) return;\n      var scene = this.scene; // Determine direction\n\n      var minScrollTo = 0;\n      var maxScrollTo = Math.round(scene.content.scrollWidth * scene.scale - scene.element.clientWidth);\n      var dir = this.mouseX - scene.element.clientWidth / 2 > 0 ? \'right\' : \'left\';\n      dir = scene.element.scrollLeft <= minScrollTo ? \'right\' : dir;\n      dir = scene.element.scrollLeft >= maxScrollTo ? \'left\' : dir;\n      Panorama_DEBUG && console.log(Panorama_LOG, \'dir:\', dir); //---\n      // step = scene width\n      // var currentIndex = Math.round(scene.element.scrollLeft/(scene.data.width * scene.scale));\n      // var scrollTo = ((dir==\'left\') ? currentIndex-1 : currentIndex+1) * (scene.data.width * scene.scale);\n      // scrollTo = (scrollTo <= minScrollTo) ? \'0\' : scrollTo;\n      // scrollTo = (scrollTo > maxScrollTo) ? maxScrollTo : scrollTo;\n      //---\n      // step = custom stops\n\n      var stops = this.options.stops;\n      if (!stops) console.error(Panorama_LOG, \'missing options "stops"\');\n      stops = stops.map(function (x) {\n        return Math.round(x * scene.scale);\n      });\n      stops.sort(function (a, b) {\n        return a - b;\n      });\n      Panorama_DEBUG && console.log(Panorama_LOG, \'stops\', stops);\n      var currentScrollCenter = Math.round(scene.element.scrollLeft + scene.element.clientWidth / 2 - (scene.element.clientWidth - scene.content.clientWidth * scene.scale) / 2); // DEBUG && console.log(LOG, \'currentScrollCenter\', currentScrollCenter);\n\n      var scrollTo;\n      var stop = 0;\n\n      if (dir == \'left\') {\n        // Find next smaller stop (relative to current scroll center)\n        var stopsReverse = stops.slice(0).reverse();\n\n        for (var i = 0; i < stopsReverse.length; i++) {\n          var item = stopsReverse[i];\n\n          if (item < currentScrollCenter) {\n            stop = item;\n            break;\n          }\n        }\n      } else {\n        // Find next higher stop (relative to current scroll center)\n        for (var i = 0; i < stops.length; i++) {\n          var item = stops[i];\n\n          if (item > currentScrollCenter + 1) {\n            stop = item;\n            break;\n          }\n        }\n      } // Calculate scroll new position\n\n\n      scrollTo = Math.floor(stop - scene.element.clientWidth / 2 + (scene.element.clientWidth - scene.content.clientWidth * scene.scale) / 2);\n      scrollTo = scrollTo <= minScrollTo ? \'0\' : scrollTo;\n      scrollTo = scrollTo > maxScrollTo ? maxScrollTo : scrollTo; // DEBUG && console.log(LOG, \'scrollTo\', scrollTo);\n      // Duration relative to distance\n\n      var duration = Math.abs(this.lastScrollTo - scrollTo) / 1200 / this.options.speed;\n      duration = duration < .2 ? .2 : duration; // DEBUG && console.log(LOG, \'speed\', this.options.speed);\n      // DEBUG && console.log(LOG, \'duration\', duration);\n      // Remember\n\n      this.lastScrollTo = scrollTo; // Tween    \n\n      gsap.isTweening(scene.element) && gsap.killTweensOf(scene.element);\n      gsap.to(scene.element, {\n        duration: duration,\n        ease: \'power4.inOut\',\n        scrollLeft: scrollTo,\n        onComplete: function onComplete() {\n          // updateCursorDir();\n          // Propagate custom_slide_active\n          scene.emit(\'custom_slide_active\', {\n            index: stops.indexOf(stop),\n            scrollTo: scrollTo\n          });\n        }\n      });\n    }\n  }]);\n\n  return _default;\n}(PluginBase_default);\n\n\n// EXTERNAL MODULE: ./style/hero.scss\nvar style_hero = __webpack_require__(11);\n\n// CONCATENATED MODULE: ./src/hero.js\n\n\n\n // import {FusionHelper} from \'./hero/core/FusionHelper\';\n\n\n // Effects\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n // import GlitchCanvas from \'./hero/fx/experimental/GlitchCanvas\';\n// import GlitchEasel from \'./hero/fx/experimental/GlitchEasel\';\n// import GlitchAppear from \'./hero/fx/experimental/GlitchAppear\';\n// import GlitchInOut from \'./hero/fx/experimental/GlitchInOut\';\n\n\n\n\n\n\n\n // Data driven\n\n\n\n\n\n\n\nvar version = __webpack_require__(5).version;\n\nconsole.log(\'[ Hero ]\', \'VERSION\', version); // Gsap Defaults\n\ngsap.defaults({\n  ease: "power2.inOut",\n  duration: 0.5\n});\ngsap.config({\n  force3D: true\n}); // Global Hero instance\n\nwindow.hero = new Hero_default(); // Use Hero instance as namespace for all classes\n\nObject.assign(window.hero, {\n  // FusionHelper, // MOVED TO FUSION\n  // #TODO: Decide between FusionHelper.throttle and helper.throttle (lodash)\n  helper: {\n    throttle: lodash_throttle_default.a,\n    debounce: lodash_debounce_default.a,\n    appendHtml: Helper_default.appendHtml\n  },\n  plugins: {\n    Panorama: Panorama_default,\n    VisualDebugger: VisualDebugger_default\n  },\n  fx: {\n    FxBase: FxBase["a" /* default */],\n    Debugger: Debugger_default,\n    FxScanner: FxScanner["a" /* default */],\n    // GlitchAppear,\n    // GlitchInOut,\n    // GlitchCanvas,\n    // GlitchEasel,\n    Fit: Fit_default,\n    Glitch: Glitch_default,\n    Magnet: Magnet_default,\n    Hide: Hide_default,\n    Appear: Appear_default,\n    Invisible: Invisible_default,\n    NoPointerEvents: NoPointerEvents_default,\n    Lottie: Lottie_default,\n    Parallax: Parallax_default,\n    Particles: Particles_default,\n    HandCursor: HandCursor_default,\n    Jump: Jump_default,\n    TypeAnimation: TypeAnimation_default,\n    TypeSpin: TypeSpin_default,\n    Spritesheet: Spritesheet_default,\n    Remove: Remove_default,\n    Fade: Fade_default,\n    PanZoom: PanZoom_default,\n    YouTube: YouTube_default,\n    IFrame: IFrame_default,\n    Sequence: Sequence_default,\n    TextInput: TextInput_default,\n    RepeatGrid: RepeatGrid_default // ex: {\n    //   anime: {\n    //     Magnet: AnimeMagnet\n    //   }\n    // }  \n\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaGVyby9oZWxwZXIvSGVscGVyLmpzPzIyMjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlcm8vY29yZS9CcmFpbi5qcz9jZjYwIiwid2VicGFjazovLy8uL3NyYy9oZXJvL2NvcmUvSGVyby5qcz8wZTM1Iiwid2VicGFjazovLy8uL3NyYy9oZXJvL2Z4L2NvcmUvR2xpdGNoLmpzPzUzNmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlcm8vZngvY29yZS9NYWduZXQuanM/MTNhOCIsIndlYnBhY2s6Ly8vLi9zcmMvaGVyby9meC9jb3JlL1NlcXVlbmNlLmpzPzI0NTYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlcm8vZngvY29yZS9BcHBlYXIuanM/MzQzMyIsIndlYnBhY2s6Ly8vLi9zcmMvaGVyby9meC9jb3JlL0hpZGUuanM/MGEyOCIsIndlYnBhY2s6Ly8vLi9zcmMvaGVyby9meC9jb3JlL0ludmlzaWJsZS5qcz9hMTkxIiwid2VicGFjazovLy8uL3NyYy9oZXJvL2Z4L2NvcmUvTm9Qb2ludGVyRXZlbnRzLmpzP2JiZTciLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlcm8vZngvY29yZS9QYXJhbGxheC5qcz80M2YyIiwid2VicGFjazovLy8uL3NyYy9oZXJvL2Z4L3R5cGUvVHlwZUFuaW1hdGlvbi5qcz9kZWI1Iiwid2VicGFjazovLy8uL3NyYy9oZXJvL2Z4L3R5cGUvVHlwZVNwaW4uanM/N2E3YyIsIndlYnBhY2s6Ly8vLi9zcmMvaGVyby9meC9leHBlcmltZW50YWwvUGFydGljbGVzLmpzP2UxNGIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlcm8vZngvZXhwZXJpbWVudGFsL1Nwcml0ZXNoZWV0LmpzPzA4MDciLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlcm8vZngvZXhwZXJpbWVudGFsL0p1bXAuanM/MTdmZiIsIndlYnBhY2s6Ly8vLi9zcmMvaGVyby9meC9leHBlcmltZW50YWwvSGFuZEN1cnNvci5qcz8zYzVkIiwid2VicGFjazovLy8uL3NyYy9oZXJvL2Z4L2V4cGVyaW1lbnRhbC9EZWJ1Z2dlci5qcz83MWY0Iiwid2VicGFjazovLy8uL3NyYy9oZXJvL2Z4L2V4cGVyaW1lbnRhbC9SZW1vdmUuanM/MmY1MiIsIndlYnBhY2s6Ly8vLi9zcmMvaGVyby9meC9leHBlcmltZW50YWwvRmFkZS5qcz80ZjE0Iiwid2VicGFjazovLy8uL3NyYy9oZXJvL2Z4L2V4cGVyaW1lbnRhbC9QYW5ab29tLmpzPzhhYmUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlcm8vZngvY29tcG9uZW50cy9Zb3VUdWJlLmpzPzlkOGYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlcm8vZngvY29tcG9uZW50cy9JRnJhbWUuanM/NTMyZCIsIndlYnBhY2s6Ly8vLi9zcmMvaGVyby9meC9jb21wb25lbnRzL0xvdHRpZS5qcz9jM2Y3Iiwid2VicGFjazovLy8uL3NyYy9oZXJvL2Z4L2NvcmUvRml0LmpzPzA1MjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlcm8vZngvZXhwZXJpbWVudGFsX2RhdGFfZHJpdmVuL1RleHRJbnB1dC5qcz83YmVhIiwid2VicGFjazovLy8uL3NyYy9oZXJvL2Z4L2V4cGVyaW1lbnRhbF9kYXRhX2RyaXZlbi9SZXBlYXRHcmlkLmpzPzgxYzQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Z1c2lvbi9wbHVnaW5zL1BsdWdpbkJhc2UuanM/NDMzNCIsIndlYnBhY2s6Ly8vLi9zcmMvZnVzaW9uL3BsdWdpbnMvd2lwL1Zpc3VhbERlYnVnZ2VyLmpzPzUzZjkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Z1c2lvbi9wbHVnaW5zL3dpcC9QYW5vcmFtYS5qcz8xMmY3Iiwid2VicGFjazovLy8uL3NyYy9oZXJvLmpzP2RiMDEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBudWxsLCBbe1xuICAgIGtleTogXCJhcHBlbmRIdG1sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZEh0bWwodGFyZ2V0LCBtYXJrdXApIHtcbiAgICAgIHRhcmdldC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIG1hcmt1cCk7XG4gICAgICByZXR1cm4gdGFyZ2V0Lmxhc3RDaGlsZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid3JhcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cmFwKGVsLCB3cmFwcGVyKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh3cmFwcGVyLCBlbCk7XG4gICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KCk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBMT0cgPSAnWyBCcmFpbiBdJztcbnZhciBERUJVRyA9IGZhbHNlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnY29uc3RydWN0b3IoKScpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHApIHtcbiAgICAgIGNvbnNvbGUubG9nKExPRywgJ2FkZCgpIHA6JywgcCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufSgpO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgQnJhaW4gZnJvbSAnLi9CcmFpbic7XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL2Z4L0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgSGVybyBdJztcbnZhciBERUJVRyA9IGZhbHNlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJicmFpblwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5icmFpbiA9IG5ldyBCcmFpbigpO1xuICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2NvbnN0cnVjdG9yKCknKTtcbiAgfVxuICAvKipcbiAgICogQWRkXG4gICAqIEZvciBwYXJhbWV0ZXJzIGFsc28gc2VlIGFkZEJlaGF2aW9yKClcbiAgICogQGV4YW1wbGVcbiAgICogXG4gICAqICAvLyBFZmZlY3QgQmVoYXZpb3JcbiAgICogIGhlcm8uYWRkKGVsLCAnY2xpY2snLCBoZXJvLmZ4Lk1hZ25ldCwge2RlbGF5OiAxMDB9KTtcbiAgICogXG4gICAqICAvLyBDdXN0b20gYmVoYXZpb3JcbiAgICogIGhlcm8uYWRkKGVsLCAndG9nZ2xlJywge1xuICAgKiAgICBzdGFydDogKCkgPT4ge1xuICAgKiAgICAgIGNvbnNvbGUubG9nKCdTVEFSVCcpO1xuICAgKiAgICB9LFxuICAgKiAgICBlbmQ6ICgpID0+IHtcbiAgICogICAgICBjb25zb2xlLmxvZygnRU5EJyk7XG4gICAqICAgIH1cbiAgICogIH0pO1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCgpIHtcbiAgICAgIC8vIERlbGVnYXRlIGRlcGVuZGluZyBvbiBzaWduYXR1cmVcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBFbGVtZW50ICYmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnc3RyaW5nJyB8fCBfdHlwZW9mKGFyZ3VtZW50c1sxXSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBhcmd1bWVudHNbMV0udHlwZSA9PT0gJ3N0cmluZycpICYmIGFyZ3VtZW50c1syXS5wcm90b3R5cGUgaW5zdGFuY2VvZiBoZXJvLmZ4LkZ4QmFzZSkge1xuICAgICAgICB0aGlzLmFkZEVmZmVjdEJlaGF2aW9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdzdHJpbmcnIHx8IF90eXBlb2YoYXJndW1lbnRzWzFdKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXS50eXBlID09PSAnc3RyaW5nJykgJiYgX3R5cGVvZihhcmd1bWVudHNbMl0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzLmFkZEJlaGF2aW9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhMT0csICdhZGQoKScsICd1bmtub3duIHNpZ25hdHVyZScpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgRWZmZWN0IEJlaGF2aW9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIGhvc3QgZWxlbWVudCB0byBhZGQgdGhlIGJlaGF2aW9yIHRvXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IHRyaWdnZXIgVGhlIHRyaWdnZXIgdHlwZSAoZS5nLiBjbGljaywgaG92ZXIsIHRvZ2dsZSBldGMuKVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEUuZy4gJ2NsaWNrJyBvciB7dHlwZTogJ2hvdmVyJywgYXJlYTogJyNjdXN0b20tdHJpZ2dlci1hcmVhJ31cbiAgICAgKiBAcGFyYW0ge0Z4QmFzZX0gRnggVGhlIGVmZmVjdCBjbGFzcyB0byBhcHBseSAoZS5nLiBoZXJvLmZ4Lk1hZ25ldClcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2Z4T3B0aW9uc10gT3B0aW9uYWwgZWZmZWN0IG9wdGlvbnMgKGUuZyB7c3BlZWQ6IDJ9KVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWZmZWN0QmVoYXZpb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWZmZWN0QmVoYXZpb3IoZWwsIHRyaWdnZXIsIEZ4LCBmeE9wdGlvbnMpIHtcbiAgICAgIC8vLS0tXG4gICAgICAvLyBDcmVhdGUgZnhcbiAgICAgIGZ4T3B0aW9ucyA9IGZ4T3B0aW9ucyA/IGZ4T3B0aW9ucyA6IHt9O1xuICAgICAgdmFyIGZ4ID0gbmV3IEZ4KGVsLCBmeE9wdGlvbnMpO1xuICAgICAgZWwgPSBmeC5lbGVtZW50O1xuICAgICAgdGhpcy5hZGRCZWhhdmlvcihlbCwgdHJpZ2dlciwgZngsIGZ4T3B0aW9ucyA/IGZ4T3B0aW9ucy5pZCA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBiZWhhdmlvclxuICAgICAqIChzdXBwb3J0cyBhdXRvbWF0aWMgYXJlYSBkZXRlY3Rpb246IGlmIG5leHQgbm9kZSBoYXMgYXR0cmlidXRlIFwiaGVyby10cmlnZ2VyLWFyZWFcIiApXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIGhvc3QgZWxlbWVudCB0byBhZGQgdGhlIGJlaGF2aW9yIHRvXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IHRyaWdnZXIgVGhlIHRyaWdnZXIgdHlwZSAoZS5nLiBjbGljaywgaG92ZXIsIHRvZ2dsZSBldGMuKVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEUuZy4gJ2NsaWNrJyBvciB7dHlwZTogJ2hvdmVyJywgYXJlYTogJyNjdXN0b20tdHJpZ2dlci1hcmVhJ31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIEFjdGlvbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24uc3RhcnQgU3RhcnQgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24uZW5kIEVuZCBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbaWRdIE9wdGlvbmFsIGlkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRCZWhhdmlvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRCZWhhdmlvcihlbCwgdHJpZ2dlciwgYWN0aW9uLCBpZCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnYWRkQmVoYXZpb3IoKScsIGVsLCB0cmlnZ2VyLCBhY3Rpb24sIGlkKTtcbiAgICAgIHZhciB0cmlnZ2VyVHlwZSA9IHR5cGVvZiB0cmlnZ2VyID09PSAnc3RyaW5nJyA/IHRyaWdnZXIgOiB0cmlnZ2VyLnR5cGUsXG4gICAgICAgICAgc3RhbmRhcmQgPSB0cnVlLFxuICAgICAgICAgIHN0YXJ0VHJpZ2dlcixcbiAgICAgICAgICBlbmRUcmlnZ2VyOyAvLy0tLVxuICAgICAgLy8gQXJlYVxuXG4gICAgICB2YXIgYXJlYSA9IHR5cGVvZiB0cmlnZ2VyID09PSAnc3RyaW5nJyA/IGVsIDogdHlwZW9mIHRyaWdnZXIuYXJlYSA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRyaWdnZXIuYXJlYSkgOiB0cmlnZ2VyLmFyZWE7XG5cbiAgICAgIGlmIChhcmVhID09IGVsKSB7XG4gICAgICAgIC8vIEF1dG8gZGV0ZWN0IGFyZWEgKG5leHQgbm9kZSBoYXMgXCJoZXJvLXRyaWdnZXItYXJlYVwiIGF0dHJpYnV0ZSlcbiAgICAgICAgaWYgKGVsLm5leHRFbGVtZW50U2libGluZyAmJiBlbC5uZXh0RWxlbWVudFNpYmxpbmcuaGFzQXR0cmlidXRlKCdoZXJvLWZ4LXRyaWdnZXItYXJlYScpKSB7XG4gICAgICAgICAgdmFyIHN2ZyA9IGVsLm5leHRFbGVtZW50U2libGluZy5xdWVyeVNlbGVjdG9yKCdzdmcnKTtcblxuICAgICAgICAgIGlmIChzdmcpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gc3ZnLnF1ZXJ5U2VsZWN0b3IoJ3BhdGgnKTtcbiAgICAgICAgICAgIHBhdGguc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgICBhcmVhID0gcGF0aDtcbiAgICAgICAgICAgIGFyZWEuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJlYSA9IGVsLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICB9IC8vLS0tXG4gICAgICAvLyBUcmlnZ2VyIHR5cGVcblxuXG4gICAgICBzd2l0Y2ggKHRyaWdnZXJUeXBlKSB7XG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgICBjYXNlICdsb2FkJzpcbiAgICAgICAgICBzdGFuZGFyZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgICBzdGFydFRyaWdnZXIgPSAnY2xpY2snO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2hvdmVyJzpcbiAgICAgICAgICBzdGFydFRyaWdnZXIgPSAnbW91c2VlbnRlcic7XG4gICAgICAgICAgZW5kVHJpZ2dlciA9ICdtb3VzZWxlYXZlJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0b2dnbGUnOlxuICAgICAgICAgIHN0YXJ0VHJpZ2dlciA9ICdjbGljayc7XG4gICAgICAgICAgZW5kVHJpZ2dlciA9ICdjbGljayc7XG4gICAgICAgICAgc3RhbmRhcmQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIGUuZy4gbW91c2VlbnRlciwgbW91c2VsZWF2ZSwgYmx1ciwgZm9jdXMgZXRjLlxuICAgICAgICAgIHN0YXJ0VHJpZ2dlciA9IHRyaWdnZXJUeXBlO1xuICAgICAgfSAvLy0tLVxuICAgICAgLy8gU2V0dXAgdHJpZ2dlcmluZyAoZXZlbnQgbGlzdGVuZXJzIGV0Yy4pXG5cblxuICAgICAgaWYgKHN0YW5kYXJkKSB7XG4gICAgICAgIC8vIHN0YXJ0VHJpZ2dlciAmJiBhcmVhLmFkZEV2ZW50TGlzdGVuZXIoc3RhcnRUcmlnZ2VyLCBzdGFydEZ1bmMpO1xuICAgICAgICAvLyBlbmRUcmlnZ2VyICYmIGFyZWEuYWRkRXZlbnRMaXN0ZW5lcihlbmRUcmlnZ2VyLCBlbmRGdW5jKTtcbiAgICAgICAgc3RhcnRUcmlnZ2VyICYmIGFjdGlvbi5zdGFydCAmJiBhcmVhLmFkZEV2ZW50TGlzdGVuZXIoc3RhcnRUcmlnZ2VyLCBhY3Rpb24uc3RhcnQuYmluZChhY3Rpb24sIGVsKSk7XG4gICAgICAgIGVuZFRyaWdnZXIgJiYgYWN0aW9uLmVuZCAmJiBhcmVhLmFkZEV2ZW50TGlzdGVuZXIoZW5kVHJpZ2dlciwgYWN0aW9uLmVuZC5iaW5kKGFjdGlvbiwgZWwpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodHJpZ2dlclR5cGUpIHtcbiAgICAgICAgICBjYXNlICcnOlxuICAgICAgICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgICAgIGNhc2UgJ2xvYWQnOlxuICAgICAgICAgICAgYWN0aW9uLnN0YXJ0KGVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndG9nZ2xlJzpcbiAgICAgICAgICAgIHZhciBvbiA9IHRydWU7XG4gICAgICAgICAgICBhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICBvbiA/IGFjdGlvbi5zdGFydChlbCkgOiBhY3Rpb24uZW5kKGVsKTtcbiAgICAgICAgICAgICAgb24gPSAhb247XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vLS0tXG4gICAgICAvLyBNZW1vcml6ZSBvbiBlbGVtZW50IGxldmVsIGlmIGZ4IGhhcyBpZFxuICAgICAgLy8gaWYgKGlkKSB7XG4gICAgICAvLyAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2FkZEJlaGF2aW9yKCknLCAnTWVtb3JpemUgb24gZWxlbWVudCB3aXRoIGlkOicsIGlkKTtcblxuXG4gICAgICB0aGlzLnByZXBhcmVFbGVtZW50KGVsKTtcbiAgICAgIGVsLmhlcm8uZngucHVzaChhY3Rpb24pOyAvLyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgZWxlbWVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGFyZUVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyZUVsZW1lbnQoZWwpIHtcbiAgICAgIGlmICghZWwuaGVybykge1xuICAgICAgICAvLyBQcmVwYXJlIG5hbWVzcGFjZVxuICAgICAgICBlbC5oZXJvID0ge1xuICAgICAgICAgIGZ4OiBbXSxcbiAgICAgICAgICBzY2FubmVkOiB7fVxuICAgICAgICB9OyAvLyBBZGQgZnggZ2V0IGZ1bmN0aW9uXG5cbiAgICAgICAgZWwuaGVyby5nZXRGeCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgLy8gRmlyc3Qgc2VhcmNoIGN1c3RvbSBpZHNcbiAgICAgICAgICAgIHZhciBmeCA9IHRoaXMuZnguZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gaXRlbS5vcHRpb25zICYmIGl0ZW0ub3B0aW9ucy5pZCA9PSBpZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnggPSBmeCB8fCB0aGlzLmZ4LmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PSBpZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5meFswXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufSgpO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIEV4cGVyaW1lbnRhbCBFZmZlY3RcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGWCA6IEdsaXRjaCBdJztcbnZhciBERUJVRyA9IGZhbHNlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICAvLyBkcHIgPSAoIXdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSA/IDEgOiAod2luZG93LmRldmljZVBpeGVsUmF0aW8+PTIpID8gMiA6IDE7XG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicmVhZHlcIiwgZmFsc2UpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInBsYXlSZXF1ZXN0ZWRcIiwgZmFsc2UpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNyY1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNhbnZhc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN0YWdlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwid2lkdGhcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJuYXR1cmFsV2lkdGhcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJuYXR1cmFsSGVpZ2h0XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZHByXCIsIDIpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNjYWxlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2VnbWVudHNcIiwgW10pO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgLy8gU2F2ZSBvcmlnaW5hbCBpbWFnZVxuICAgICAgdGhpcy5vcmlnaW5hbCA9IHRoaXMuZWxlbWVudDtcbiAgICAgIHRoaXMuc3JjID0gdGhpcy5vcmlnaW5hbC5nZXRBdHRyaWJ1dGUoJ3NyYycpOyAvLyBNYWtlIHN1cmUgaW1hZ2UgaXMgZnVsbHkgbG9hZGVkIGJlZm9yZSBjcmVhdGluZ1xuXG4gICAgICB0aGlzLm9yaWdpbmFsLmNvbXBsZXRlID8gdGhpcy5jcmVhdGUoKSA6IHRoaXMub3JpZ2luYWwuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuY3JlYXRlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2NyZWF0ZSgpJyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubmF0dXJhbFdpZHRoID0gdGhpcy5vcmlnaW5hbC5uYXR1cmFsV2lkdGg7XG4gICAgICAgIHRoaXMubmF0dXJhbEhlaWdodCA9IHRoaXMub3JpZ2luYWwubmF0dXJhbEhlaWdodDsgLy8gQ3JlYXRlIGNhbnZhc1xuXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsLmdldEF0dHJpYnV0ZSgnaWQnKSAmJiBjYW52YXMuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMub3JpZ2luYWwuZ2V0QXR0cmlidXRlKCdpZCcpKTtcbiAgICAgICAgdGhpcy5zdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZSh0aGlzLmNhbnZhcyk7XG4gICAgICAgIHRoaXMub3JpZ2luYWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5jYW52YXMsIHRoaXMub3JpZ2luYWwubmV4dFNpYmxpbmcpO1xuICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMub3JpZ2luYWwpOyAvLyBsZXQgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMub3JpZ2luYWwpO1xuICAgICAgICAvLyBjYW52YXMuc3R5bGUud2lkdGggPSBjb21wdXRlZFN0eWxlLndpZHRoO1xuXG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGNvbXB1dGVkU3R5bGUud2lkdGg7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBjb21wdXRlZFN0eWxlLmhlaWdodDtcbiAgICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSBjb21wdXRlZFN0eWxlLmxlZnQ7XG4gICAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSBjb21wdXRlZFN0eWxlLnRvcDtcbiAgICAgICAgY2FudmFzLnN0eWxlLnRyYW5zZm9ybSA9IGNvbXB1dGVkU3R5bGUudHJhbnNmb3JtOyAvLyBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcblxuICAgICAgICB0aGlzLndpZHRoID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS53aWR0aCkgKiB0aGlzLmRwcjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmhlaWdodCkgKiB0aGlzLmRwcjtcbiAgICAgICAgdGhpcy5zY2FsZSA9IHRoaXMud2lkdGggLyB0aGlzLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgdGhpcy5zY2FsZSA9IHRoaXMuaGVpZ2h0IC8gdGhpcy5uYXR1cmFsSGVpZ2h0OyAvLyBjYW52YXMud2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICAgIC8vIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gdGhpcy5jYW52YXM7IC8vIHRoaXMub3JpZ2luYWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm9yaWdpbmFsKTtcbiAgICAgICAgLy8gdGhpcy5vcmlnaW5hbC5yZW1vdmUoKTtcblxuICAgICAgICB0aGlzLm9yaWdpbmFsLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBDcmVhdGUgc2VnbWVudHNcblxuICAgICAgICB2YXIgc2VlZEluZGV4ID0gMCxcbiAgICAgICAgICAgIHRvcCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgc2VlZCA9IE1hdGgucm91bmQodGhpcy5vcHRpb25zLnNlZWRbc2VlZEluZGV4XSAqIHRoaXMub3B0aW9ucy5mYWN0b3IpO1xuICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBjcmVhdGVqcy5CaXRtYXAodGhpcy5zcmMpO1xuICAgICAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNGRkZGRkZcIikuZHJhd1JlY3QoMCwgdG9wLCB0aGlzLndpZHRoLCBzZWVkKTtcbiAgICAgICAgICBpbWFnZS5tYXNrID0gc2hhcGU7XG4gICAgICAgICAgaW1hZ2Uuc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoaW1hZ2UpO1xuICAgICAgICAgIHRoaXMuc2VnbWVudHMucHVzaChpbWFnZSk7IC8vIEVuZFxuICAgICAgICAgIC8vIGlmICh0b3AgPj0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5oZWlnaHQpICogdGhpcy5kcHIpIGJyZWFrO1xuXG4gICAgICAgICAgaWYgKHRvcCA+PSB0aGlzLmhlaWdodCAqIHRoaXMuZHByKSBicmVhazsgLy8gVEVNUFxuICAgICAgICAgIC8vIFRFTVBcbiAgICAgICAgICAvLyBURU1QXG4gICAgICAgICAgLy8gaWYgKHRvcCA+IDEwMCkgYnJlYWtcbiAgICAgICAgICAvLyBJdGVyYXRlIFxuXG4gICAgICAgICAgdG9wICs9IHNlZWQ7XG4gICAgICAgICAgc2VlZEluZGV4ID0gc2VlZEluZGV4ID49IHRoaXMub3B0aW9ucy5zZWVkLmxlbmd0aCAtIDEgPyAwIDogKytzZWVkSW5kZXg7XG4gICAgICAgIH0gLy8gVGltZWxpbmVcblxuXG4gICAgICAgIHRoaXMudGltZWxpbmUgPSBnc2FwLnRpbWVsaW5lKHtcbiAgICAgICAgICBwYXVzZWQ6IHRydWUsXG4gICAgICAgICAgZGVsYXk6IHRoaXMub3B0aW9ucy5kZWxheSAvIDEwMDAsXG4gICAgICAgICAgcmVwZWF0OiB0aGlzLm9wdGlvbnMucmVwZWF0LFxuICAgICAgICAgIHJlcGVhdERlbGF5OiB0aGlzLm9wdGlvbnMucmVwZWF0RGVsYXkgLyAxMDAwLFxuICAgICAgICAgIHlveW86IHRoaXMub3B0aW9ucy55b3lvLFxuICAgICAgICAgIG9uVXBkYXRlOiB0aGlzLnN0YWdlLnVwZGF0ZS5iaW5kKHRoaXMuc3RhZ2UpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKHNlZ21lbnQsIGluZGV4KSB7XG4gICAgICAgICAgX3RoaXMyLnRpbWVsaW5lLmZyb20oc2VnbWVudCwge1xuICAgICAgICAgICAgeDogKE1hdGgucmFuZG9tKCkgLSAuNSkgKiAyMCAqIF90aGlzMi5vcHRpb25zLnBvd2VyLFxuICAgICAgICAgICAgYWxwaGE6IDAsXG4gICAgICAgICAgICBkdXJhdGlvbjogMC41LFxuICAgICAgICAgICAgZWFzZTogX3RoaXMyLm9wdGlvbnMuZWFzZWluZ1xuICAgICAgICAgIH0sIFwiXCIuY29uY2F0KGluZGV4ICogX3RoaXMyLm9wdGlvbnMuc3RhZ2dlciAvIDEwMDApKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGltZWxpbmUudGltZVNjYWxlKHRoaXMudGltZWxpbmUuZHVyYXRpb24oKSAvICh0aGlzLm9wdGlvbnMuZHVyYXRpb24gLyAxMDAwKSk7XG4gICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnBsYXlSZXF1ZXN0ZWQgJiYgdGhpcy50aW1lbGluZS5wbGF5KCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coTE9HLCAnRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICAgIHRoaXMudGltZWxpbmUucGxheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wbGF5UmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHtcbiAgICAgIHRoaXMudGltZWxpbmUucmV2ZXJzZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMudGltZWxpbmUucGF1c2UoMCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShGeEJhc2UpO1xuXG5fZGVmaW5lUHJvcGVydHkoX2RlZmF1bHQsIFwibWFuaWZlc3RcIiwge1xuICBpZDogJ2dsaXRjaCcsXG4gIG9wdGlvbnM6IHtcbiAgICB0cmlnZ2VyOiAnbG9hZCcsXG4gICAgZHVyYXRpb246IDEwMDAsXG4gICAgZGVsYXk6IDEwMCxcbiAgICByZXBlYXQ6IDAsXG4gICAgcmVwZWF0RGVsYXk6IDEwMDAsXG4gICAgeW95bzogdHJ1ZSxcbiAgICBzZWVkOiBbMSwgNiwgMywgMSwgMywgOCwgMiwgMSwgOSwgNCwgNywgMV0sXG4gICAgZmFjdG9yOiAxMCxcbiAgICBwb3dlcjogODAsXG4gICAgc3RhZ2dlcjogMTAsXG4gICAgZWFzaW5nOiAncG93ZXI0LmluT3V0JyAvLyBiYWNrLm91dCgzKSxcblxuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBNYWduZXQgXSc7XG52YXIgREVCVUcgPSBmYWxzZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgZ3NhcC50byh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgc2NhbGU6IHRoaXMub3B0aW9ucy5zY2FsZSxcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnNTAlIDUwJScsXG4gICAgICAgIGRlbGF5OiB0aGlzLm9wdGlvbnMuZGVsYXkgLyAxMDAwLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLmR1cmF0aW9uIC8gMTAwMCxcbiAgICAgICAgZWFzZTogJ3Bvd2VyNC5vdXQoOSknXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHtcbiAgICAgIGdzYXAuaXNUd2VlbmluZyh0aGlzLmVsZW1lbnQpICYmIGdzYXAua2lsbFR3ZWVuc09mKHRoaXMuZWxlbWVudCwgJ3NjYWxlJyk7XG4gICAgICBnc2FwLnRvKHRoaXMuZWxlbWVudCwge1xuICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5kdXJhdGlvbiAvIDEwMDAsXG4gICAgICAgIGVhc2U6IHRoaXMub3B0aW9ucy5lYXNlT3V0XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnbWFnbmV0JyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdob3ZlcicsXG4gICAgZGVsYXk6IDAsXG4gICAgZHVyYXRpb246IDUwMCxcbiAgICBzY2FsZTogMS4yLFxuICAgIGVhc2VPdXQ6ICdiYWNrLm91dCgzKSdcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogU2VxdWVuY2UgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN0ZXBzXCIsIFtdKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ0aW1lbGluZVwiLCB2b2lkIDApO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScpOyAvLyBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdpbml0KCknLCAndGhpcy5lbGVtZW50LmNoaWxkcmVuOicsIHRoaXMuZWxlbWVudC5jaGlsZHJlbik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbGVtZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuc3RlcHMucHVzaCh0aGlzLmVsZW1lbnQuY2hpbGRyZW5baV0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0ZXBzLnJldmVyc2UoKTtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScsICdzdGVwczonLCB0aGlzLnN0ZXBzKTtcbiAgICAgIGdzYXAuc2V0KHRoaXMuc3RlcHMsIHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSk7XG4gICAgICBnc2FwLnNldCh0aGlzLnN0ZXBzWzBdLCB7XG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH0pO1xuICAgICAgdmFyIHRsID0gdGhpcy50aW1lbGluZSA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICBwYXVzZWQ6IHRydWUsXG4gICAgICAgIGRlbGF5OiB0aGlzLm9wdGlvbnMuZGVsYXkgLyAxMDAwLFxuICAgICAgICByZXBlYXQ6IHRoaXMub3B0aW9ucy5yZXBlYXQsXG4gICAgICAgIHJlcGVhdERlbGF5OiB0aGlzLm9wdGlvbnMucmVwZWF0RGVsYXkgLyAxMDAwLFxuICAgICAgICB5b3lvOiB0aGlzLm9wdGlvbnMueW95b1xuICAgICAgfSk7XG4gICAgICB0aGlzLnN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHRsLnRvKGl0ZW0sIHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0sIGluZGV4ICogX3RoaXMyLm9wdGlvbnMuc3RlcER1cmF0aW9uIC8gMTAwMCk7XG4gICAgICAgIHZhciBsYXN0ID0gaW5kZXggPj0gX3RoaXMyLnN0ZXBzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgICAgdGwudG8oaXRlbSwge1xuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSwgKGluZGV4ICsgMSkgKiBfdGhpczIub3B0aW9ucy5zdGVwRHVyYXRpb24gLyAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdGhpcy50aW1lbGluZS5wbGF5KDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgdGhpcy50aW1lbGluZS5wYXVzZSgwKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnc2VxdWVuY2UnLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2xvYWQnLFxuICAgIGRlbGF5OiAyMDAsXG4gICAgc3RlcER1cmF0aW9uOiA5MCxcbiAgICByZXBlYXREZWxheTogNTAwLFxuICAgIHlveW86IHRydWUsXG4gICAgcmVwZWF0OiAtMVxuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBBcHBlYXIgXSc7XG52YXIgREVCVUcgPSBmYWxzZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIGdzYXAuc2V0KHRoaXMuZWxlbWVudCwge1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICBnc2FwLnRvKHRoaXMuZWxlbWVudCwge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBkZWxheTogdGhpcy5vcHRpb25zLmRlbGF5IC8gMTAwMCxcbiAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5kdXJhdGlvbiAvIDEwMDBcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdhcHBlYXInLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2xvYWQnLFxuICAgIGRlbGF5OiAwLFxuICAgIGR1cmF0aW9uOiA1MDBcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogSGlkZSBdJztcbnZhciBERUJVRyA9IGZhbHNlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge31cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIGdzYXAudG8odGhpcy5lbGVtZW50LCB7XG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIGRlbGF5OiB0aGlzLm9wdGlvbnMuZGVsYXkgLyAxMDAwLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLmR1cmF0aW9uIC8gMTAwMFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShGeEJhc2UpO1xuXG5fZGVmaW5lUHJvcGVydHkoX2RlZmF1bHQsIFwibWFuaWZlc3RcIiwge1xuICBpZDogJ2hpZGUnLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2xvYWQnLFxuICAgIGRlbGF5OiAwLFxuICAgIGR1cmF0aW9uOiA1MDBcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogSW5zaXZpYmxlIF0nO1xudmFyIERFQlVHID0gZmFsc2U7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdpbnZpc2libGUnLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2xvYWQnXG4gIH1cbn0pO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIEV4cGVyaW1lbnRhbCBFZmZlY3RcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGWCA6IE5vUG9pbnRlckV2ZW50cyBdJztcbnZhciBERUJVRyA9IGZhbHNlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge31cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICduby1wb2ludGVyLWV2ZW50cycsXG4gIG9wdGlvbnM6IHtcbiAgICB0cmlnZ2VyOiAnbm9uZSdcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gUGFyYWxsYXhcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGWCA6IFBhcmFsbGF4IF0nO1xudmFyIERFQlVHID0gdHJ1ZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJsYXllcnNcIiwgW10pO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScpOyAvLyAjSURFQTogTW9iaWxlOiBhdXRvIGFuaW1hdGlvblxuICAgICAgLy8gI0lERUE6IElkbGU6IGF1dG8gYW5pbWF0aW9uP1xuXG4gICAgICB2YXIgdmlld3BvcnRXaWR0aCA9IHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50KS53aWR0aCk7XG4gICAgICB2YXIgdmlld3BvcnRIZWlnaHQgPSBwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudCkuaGVpZ2h0KTsgLy8gTGF5ZXJzXG5cbiAgICAgIHZhciBsYXllckVsZW1lbnRzID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1toZXJvLWZ4LXBhcmFsbGF4LWxheWVyXScpO1xuICAgICAgbGF5ZXJFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBhdHRyID0gaXRlbS5nZXRBdHRyaWJ1dGUoJ2hlcm8tZngtcGFyYWxsYXgtbGF5ZXInKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBoZXJvLmZ4LkZ4U2Nhbm5lci5leHRyYWN0T3B0aW9ucyhhdHRyKTtcbiAgICAgICAgb3B0aW9ucy5lbGVtZW50ID0gaXRlbTtcbiAgICAgICAgb3B0aW9ucy54ID0gJChpdGVtKS5wb3NpdGlvbigpLmxlZnQ7XG4gICAgICAgIG9wdGlvbnMueSA9ICQoaXRlbSkucG9zaXRpb24oKS50b3A7XG5cbiAgICAgICAgX3RoaXMyLmxheWVycy5wdXNoKG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdpbml0KCknLCAndGhpcy5sYXllcnMnLCB0aGlzLmxheWVycyk7XG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgeCA9IGV2dC5jbGllbnRYIC0gZXZ0LmN1cnJlbnRUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgICAgdmFyIHkgPSBldnQuY2xpZW50WSAtIGV2dC5jdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgICAgdmFyIHBlcmNlbnRYID0gKHZpZXdwb3J0V2lkdGggLyAyIC0geCkgLyAodmlld3BvcnRXaWR0aCAvIDIpO1xuICAgICAgICB2YXIgcGVyY2VudFkgPSAodmlld3BvcnRIZWlnaHQgLyAyIC0geSkgLyAodmlld3BvcnRIZWlnaHQgLyAyKTtcblxuICAgICAgICBfdGhpczIubGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBnc2FwLnRvKGl0ZW0uZWxlbWVudCwgMSwge1xuICAgICAgICAgICAgeDogXCJcIi5jb25jYXQoaXRlbS54ICsgdmlld3BvcnRXaWR0aCAqIHBlcmNlbnRYICogaXRlbS56IC8gMTAwMDApLFxuICAgICAgICAgICAgeTogXCJcIi5jb25jYXQoaXRlbS55ICsgdmlld3BvcnRIZWlnaHQgKiBwZXJjZW50WSAqIGl0ZW0ueiAvIDIwMDAwKSxcbiAgICAgICAgICAgIGVhc2U6IFwicG93ZXIyLm91dFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge31cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdwYXJhbGxheCcsXG4gIG9wdGlvbnM6IHtcbiAgICB0cmlnZ2VyOiAnbG9hZCdcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xuaW1wb3J0IHNwbGl0dGluZyBmcm9tIFwic3BsaXR0aW5nXCI7XG52YXIgTE9HID0gJ1sgRlggOiBUeXBlQW5pbWF0aW9uIF0nO1xudmFyIERFQlVHID0gZmFsc2U7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY2hhcmFjdGVyc1wiLCB2b2lkIDApO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwic3RhcnRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnaW5pdCgpJywgdGhpcy5vcHRpb25zKTsgLy8gQ2FzZTE6IG5vIGxpbmVzXG4gICAgICAvLyBDYXNlMjogd2l0aCBsaW5lc1xuICAgICAgLy8gTGluZXNcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW5lcykge1xuICAgICAgICB0aGlzLm9wdGlvbnMubGluZXMudW5zaGlmdCh0aGlzLmVsZW1lbnQudGV4dENvbnRlbnQpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuaW5uZXJUZXh0ID0gJyc7XG4gICAgICAgIHRoaXMub3B0aW9ucy5saW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaGVyby5oZWxwZXIuYXBwZW5kSHRtbChfdGhpczIuZWxlbWVudCwgXCI8c3BhbiBjbGFzcz1cXFwibGluZVxcXCIgZGF0YS1zcGxpdHRpbmc9XFxcIlxcXCI+XCIuY29uY2F0KGl0ZW0sIFwiPC9zcGFuPlwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzcGxpdHRpbmcoKTtcbiAgICAgIGhlcm8uaGVscGVyLmFwcGVuZEh0bWwodGhpcy5lbGVtZW50LCBcIjxkaXYgY2xhc3M9XFxcImN1cnNvclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IGlubGluZS1ibG9jazsgb3BhY2l0eTogMTsgbWFyZ2luLWxlZnQ6IDZweDsgbWF4LXdpZHRoOiAzcHg7IGNvbG9yOiB0cmFuc3BhcmVudDsgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XFxcIj58PC9kaXY+XCIpO1xuICAgICAgdmFyIGN1cnNvciA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuY3Vyc29yJyk7XG4gICAgICB2YXIgdGwgPSBnc2FwLnRpbWVsaW5lKHtcbiAgICAgICAgcmVwZWF0OiAtMVxuICAgICAgfSk7XG4gICAgICB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmxpbmUnKS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lLCBpbmRleCkge1xuICAgICAgICBnc2FwLnNldChsaW5lLCB7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2hhcnMgPSBsaW5lLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jaGFyJyk7XG4gICAgICAgIGNoYXJzID0gW10uc2xpY2UuY2FsbChjaGFycyk7XG4gICAgICAgIHRsLnRvKGxpbmUsIHtcbiAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lJyxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KTtcbiAgICAgICAgdGwuZnJvbVRvKGNoYXJzLCB7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lJyxcbiAgICAgICAgICBkdXJhdGlvbjogMC4wMSxcbiAgICAgICAgICBzdGFnZ2VyOiAwLjA3XG4gICAgICAgIH0pO1xuICAgICAgICB0bC50byh7fSwge1xuICAgICAgICAgIGR1cmF0aW9uOiAxLjdcbiAgICAgICAgfSk7XG4gICAgICAgIHRsLnRvKGNoYXJzLnJldmVyc2UoKSwge1xuICAgICAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgICAgICBkdXJhdGlvbjogMC4wMSxcbiAgICAgICAgICBzdGFnZ2VyOiAwLjAxXG4gICAgICAgIH0pO1xuICAgICAgICB0bC50byhsaW5lLCB7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pO1xuICAgICAgICB0bC50byh7fSwge1xuICAgICAgICAgIGR1cmF0aW9uOiAwLjFcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gdGhpcy5jaGFyYWN0ZXJzID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jaGFyJyk7XG4gICAgICAvLyAvLyBjb25zb2xlLmxvZygnbGlzdCcsIHRoaXMub3B0aW9ucy5saW5lcyk7XG4gICAgICAvLyAvLyBJbml0aWFsIHN0YXRlXG4gICAgICAvLyBnc2FwLnNldCh0aGlzLmNoYXJhY3RlcnMsIHtvcGFjaXR5OiAwfSk7ICAgIFxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ3N0YXJ0KCknKTsgLy8gZ3NhcC5zZXQodGhpcy5lbGVtZW50LCB7XG4gICAgICAvLyAgIC8vIHNrZXdZOiAtMTAsXG4gICAgICAvLyAgIC8vIGZvcmNlM0Q6IHRydWVcbiAgICAgIC8vIH0pO1xuICAgICAgLy8gZ3NhcC5mcm9tVG8odGhpcy5jaGFyYWN0ZXJzLCB7XG4gICAgICAvLyAgIHNjYWxlOiAyLFxuICAgICAgLy8gfSxcbiAgICAgIC8vIHsgb3BhY2l0eTogMSwgc2NhbGU6IDEsXG4gICAgICAvLyAgIGRlbGF5OiB0aGlzLm9wdGlvbnMuZGVsYXkvMTAwMCwgZHVyYXRpb246IDAuNCwgXG4gICAgICAvLyAgIHN0YWdnZXI6IHRoaXMub3B0aW9ucy5zdGFnZ2VyLzEwMDAsXG4gICAgICAvLyAgIGVhc2U6ICdwb3dlci5vdXQoNiknXG4gICAgICAvLyB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAndHlwZScsXG4gIG9wdGlvbnM6IHtcbiAgICB0cmlnZ2VyOiAnbG9hZCcsXG4gICAgc3RhZ2dlcjogMTAwLFxuICAgIGRlbGF5OiA1MDAsXG4gICAgbGluZXM6IG51bGxcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xuaW1wb3J0IHNwbGl0dGluZyBmcm9tIFwic3BsaXR0aW5nXCI7XG52YXIgTE9HID0gJ1sgRlggOiBUeXBlU3BpbiBdJztcbnZhciBERUJVRyA9IGZhbHNlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNoYXJhY3RlcnNcIiwgdm9pZCAwKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcInN0YXJ0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnaW5pdCgpJywgdGhpcy5vcHRpb25zKTsgLy8gQ2FzZTE6IG5vIGxpbmVzXG4gICAgICAvLyBDYXNlMjogd2l0aCBsaW5lc1xuICAgICAgLy8gTGluZXNcbiAgICAgIC8vIGlmICh0aGlzLm9wdGlvbnMubGluZXMpIHtcbiAgICAgIC8vICAgdGhpcy5vcHRpb25zLmxpbmVzLnVuc2hpZnQodGhpcy5lbGVtZW50LnRleHRDb250ZW50KVxuICAgICAgLy8gICB0aGlzLmVsZW1lbnQuaW5uZXJUZXh0ID0gJydcbiAgICAgIC8vICAgdGhpcy5vcHRpb25zLmxpbmVzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAvLyAgICAgaGVyby5oZWxwZXIuYXBwZW5kSHRtbCggdGhpcy5lbGVtZW50LCBgPHNwYW4gY2xhc3M9XCJsaW5lXCIgZGF0YS1zcGxpdHRpbmc9XCJcIj4ke2l0ZW19PC9zcGFuPmAgKTtcbiAgICAgIC8vICAgfSlcbiAgICAgIC8vIH1cblxuICAgICAgdGhpcy5vcHRpb25zLndpZHRoID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgdGhpcy5vcHRpb25zLmhlaWdodCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSB0aGlzLm9wdGlvbnMud2lkdGggKyAncHgnO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMub3B0aW9ucy5oZWlnaHQgKyAncHgnO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgdmFyIHRleHRDb250ZW50ID0gdGhpcy5lbGVtZW50LnRleHRDb250ZW50OyAvLyBFbXB0eVxuXG4gICAgICB3aGlsZSAodGhpcy5lbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudC5sYXN0Q2hpbGQpO1xuICAgICAgfSAvLyB0aGlzLmVsZW1lbnQuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjNzc3JztcbiAgICAgIC8vIEFkZCBjb250ZW50IHR3aWNlXG5cblxuICAgICAgaGVyby5oZWxwZXIuYXBwZW5kSHRtbCh0aGlzLmVsZW1lbnQsIFwiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwibGluZTFcXFwiIHN0eWxlPVxcXCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDtcXFwiPlwiLmNvbmNhdCh0ZXh0Q29udGVudCwgXCI8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJsaW5lMlxcXCIgc3R5bGU9XFxcInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwO1xcXCI+XCIpLmNvbmNhdCh0ZXh0Q29udGVudCwgXCI8L2Rpdj5cIikpOyAvLyBzcGxpdHRpbmcoKTtcblxuICAgICAgdmFyIGxpbmUxID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5saW5lMScpO1xuICAgICAgdmFyIGxpbmUyID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5saW5lMicpO1xuICAgICAgZ3NhcC5zZXQobGluZTIsIHtcbiAgICAgICAgeTogdGhpcy5vcHRpb25zLmhlaWdodFxuICAgICAgfSk7XG4gICAgICB0aGlzLnRpbWVsaW5lID0gZ3NhcC50aW1lbGluZSh7XG4gICAgICAgIHJlcGVhdDogMCxcbiAgICAgICAgcGF1c2VkOiB0cnVlXG4gICAgICB9KS50byhsaW5lMSwge1xuICAgICAgICB5OiAtdGhpcy5vcHRpb25zLmhlaWdodCxcbiAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5kdXJhdGlvbiAvIDEwMDBcbiAgICAgIH0pLnRvKGxpbmUyLCB7XG4gICAgICAgIHk6IDAsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLm9wdGlvbnMuZHVyYXRpb24gLyAxMDAwXG4gICAgICB9LCAnLT0gMC41Jyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnc3RhcnQoKScpO1xuICAgICAgdGhpcy50aW1lbGluZS5wbGF5KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdzdGFydCgpJyk7XG4gICAgICB0aGlzLnRpbWVsaW5lLnJldmVyc2UoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAndHlwZS1zcGluJyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdob3ZlcicsXG4gICAgLy8gc3RhZ2dlcjogMTAwLFxuICAgIC8vIGRlbGF5OiA1MDAsXG4gICAgZHVyYXRpb246IDUwMFxuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBQYXJ0aWNsZXMgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICAvLyBFZmZlY3QgY2VudGVyXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY2VudGVyXCIsIHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9KTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH0gLy8gVEVNUDogVXNlIEZ1c2lvbkhlbHBlciBpbnN0ZWFkXG4gIC8vIFRFTVA6IFVzZSBGdXNpb25IZWxwZXIgaW5zdGVhZFxuXG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJhcHBlbmRIdG1sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZEh0bWwodGFyZ2V0LCBtYXJrdXApIHtcbiAgICAgIHRhcmdldC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIG1hcmt1cCk7XG4gICAgICByZXR1cm4gdGFyZ2V0Lmxhc3RDaGlsZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnaW5pdCgpJywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuYXBwZW5kSHRtbChkb2N1bWVudC5ib2R5LCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCIgd2lkdGg9XFxcIjgyXFxcIiBoZWlnaHQ9XFxcIjEyOVxcXCIgdmlld0JveD1cXFwiMCAwIDgyIDEyOVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmVcXFwiPlxcbiAgICAgIDxjaXJjbGUgaWQ9XFxcInRwbENpcmNsZVxcXCIgY3g9XFxcIjkuNVxcXCIgY3k9XFxcIjkuNVxcXCIgcj1cXFwiOS41XFxcIiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiNmZmZcXFwiIHN0cm9rZS13aWR0aD1cXFwiM1xcXCIvPlxcbiAgICAgIDxwYXRoIGlkPVxcXCJ0cGxUcmlhbmdsZVxcXCIgZD1cXFwiTTkuNSwwLDE5LDE3SDBaXFxcIiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiNmZmZcXFwiIHN0cm9rZS13aWR0aD1cXFwiM1xcXCIvPlxcbiAgICAgIDxyZWN0IGlkPVxcXCJ0cGxSZWN0XFxcIiB3aWR0aD1cXFwiMTlcXFwiIGhlaWdodD1cXFwiMTlcXFwiIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiI2ZmZlxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIzXFxcIi8+XFxuICAgIDwvc3ZnPlwiKTsgLy8gR2F0aGVyIHRlbXBsYXRlc1xuXG4gICAgICB0aGlzLnRlbXBsYXRlcyA9IFt7XG4gICAgICAgIG5vZGU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cGxDaXJjbGUnKVxuICAgICAgfSwge1xuICAgICAgICBub2RlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHBsVHJpYW5nbGUnKVxuICAgICAgfSwge1xuICAgICAgICBub2RlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHBsUmVjdCcpXG4gICAgICB9XTsgLy8gQ2FjaGUgd2lkdGgvaGVpZ2h0XG5cbiAgICAgIHRoaXMudGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIHJlY3QgPSBpdGVtLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGl0ZW0ud2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICBpdGVtLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICd1cGRhdGUoKScpOyAvLyBsZXQgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudCk7XG4gICAgICAvLyB0aGlzLmNlbnRlciA9IHtcbiAgICAgIC8vICAgbGVmdDogcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5sZWZ0KSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGUud2lkdGgpLzIsXG4gICAgICAvLyAgIHRvcDogcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS50b3ApICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5oZWlnaHQpLzIgXG4gICAgICAvLyB9O1xuICAgICAgLy8gREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAndXBkYXRlKCkgY2VudGVyOicsIHRoaXMuY2VudGVyKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0TG9jYWxCb3VuZGluZ0NsaWVudFJlY3QoZWwpIHtcbiAgICAgICAgdmFyIGEgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGIgPSBlbC5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6IGEubGVmdCAtIGIubGVmdCxcbiAgICAgICAgICB0b3A6IGEudG9wIC0gYi50b3AsXG4gICAgICAgICAgd2lkdGg6IGEud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBhLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjdCA9IGdldExvY2FsQm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxlbWVudCk7XG4gICAgICB0aGlzLmNlbnRlciA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5yb3VuZChyZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMiksXG4gICAgICAgIHRvcDogTWF0aC5yb3VuZChyZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMilcbiAgICAgIH07XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdjZW50ZXInLCB0aGlzLmNlbnRlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnc3RhcnQoKScpO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIHZhciBzdmcgPSB0aGlzLmFwcGVuZEh0bWwodGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQsIFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIxXFxcIiB2aWV3Qm94PVxcXCIwIDAgMSAxXFxcIiBzdHlsZT1cXFwicG9pbnRlci1ldmVudHM6IG5vbmU7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgb3ZlcmZsb3c6IHZpc2libGU7XFxcIj48L3N2Zz5cIik7XG4gICAgICBzdmcuc3R5bGUubGVmdCA9IHRoaXMuY2VudGVyLmxlZnQgKyAncHgnO1xuICAgICAgc3ZnLnN0eWxlLnRvcCA9IHRoaXMuY2VudGVyLnRvcCArICdweCc7IC8vIEdlbmVyYXRlXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgIHZhciB0cGwgPSB0aGlzLnRlbXBsYXRlc1tNYXRoLmNlaWwoTWF0aC5yYW5kb20oKSAqIHRoaXMudGVtcGxhdGVzLmxlbmd0aCkgLSAxXTtcbiAgICAgICAgdmFyIG5vZGUgPSB0cGwubm9kZS5jbG9uZU5vZGUoKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3JhbmRvbS0nICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwMDApKTtcbiAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgbm9kZS5zdHlsZS5vcGFjaXR5ID0gMDsgLy8gbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcrKG9yaWdpblgtdHBsLndpZHRoLzIpKydweCwgJysob3JpZ2luWS10cGwuaGVpZ2h0LzIpKydweCknO1xuXG4gICAgICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgtMTBweCwgLTEwcHgpJztcbiAgICAgICAgc3ZnLmFwcGVuZENoaWxkKG5vZGUpOyAvL2dzYXAudG8obm9kZSwge2R1cmF0aW9uOiAwLjIqaSwgb3BhY2l0eTogMSwgeTogJy09ODAnLCByb3RhdGlvbjogMzYwLCB0cmFuc2Zvcm1PcmlnaW46IFwiNTAlIDUwJVwifSk7XG5cbiAgICAgICAgdmFyIHRsID0gZ3NhcC50aW1lbGluZSh7XG4gICAgICAgICAgZGVsYXk6IDAuMDUgKiBpXG4gICAgICAgIH0pOyAvLyB0bC50aW1lU2NhbGUoMC4xKTtcblxuICAgICAgICB2YXIgeCA9IGkgJSAyID8gLTQwICogKE1hdGgucmFuZG9tKCkgKiAyICogdGhpcy5vcHRpb25zLnBvd2VyKSA6IDQwICogKE1hdGgucmFuZG9tKCkgKiAyICogdGhpcy5vcHRpb25zLnBvd2VyKTtcbiAgICAgICAgdmFyIHkgPSAtMzAgKiAoaSAvIDIgKyAxKSAqIHRoaXMub3B0aW9ucy5wb3dlcjtcbiAgICAgICAgdGwudG8obm9kZSwge1xuICAgICAgICAgIGR1cmF0aW9uOiAxLjQsXG4gICAgICAgICAgZWFzZTogXCJwb3dlcjMub3V0XCIsXG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHJvdGF0aW9uOiAxMzAsXG4gICAgICAgICAgc2NhbGU6IHRoaXMub3B0aW9ucy5zY2FsZSxcbiAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFwiNTAlIDUwJVwiXG4gICAgICAgIH0sIDApO1xuICAgICAgICB0bC50byhub2RlLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMixcbiAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0sIDApO1xuICAgICAgICB0bC50byhub2RlLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIFwiLT1cIi5jb25jYXQoMC4zICogdGhpcy5vcHRpb25zLmRlY2F5KSk7XG4gICAgICAgIHRsLmV2ZW50Q2FsbGJhY2soXCJvbkNvbXBsZXRlXCIsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcblxuICAgICAgICAgIGlmIChwYXJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBbbm9kZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdwYXJ0aWNsZXMnLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2NsaWNrJyxcbiAgICBzY2FsZTogMixcbiAgICBwb3dlcjogMixcbiAgICBkZWNheTogM1xuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBTcHJpdGVzaGVldCBdJztcbnZhciBERUJVRyA9IGZhbHNlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInRsXCIsIHZvaWQgMCk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdvcHRpb25zOicsIHRoaXMub3B0aW9ucyk7IC8vIFByZXBhcmVcbiAgICAgIC8vI0JVRzogZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgaXMgYWx3YXlzIG5vbi1zY2FsZWQgaW4gZ2xvYmFsIHNwYWNlXG4gICAgICAvLyBsZXQgYm91bmRzID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgLy8gISh0aGlzLm9wdGlvbnMud2lkdGgpICYmICh0aGlzLm9wdGlvbnMud2lkdGggPSBib3VuZHMud2lkdGgpOyBcbiAgICAgIC8vICEodGhpcy5vcHRpb25zLmhlaWdodCkgJiYgKHRoaXMub3B0aW9ucy5oZWlnaHQgPSBib3VuZHMuaGVpZ2h0KTtcbiAgICAgIC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBzZWVtcyB0byB3b3JrIGJldHRlciB3aXRoIHNjYWxpbmdcblxuICAgICAgIXRoaXMub3B0aW9ucy53aWR0aCAmJiAodGhpcy5vcHRpb25zLndpZHRoID0gdGhpcy5lbGVtZW50Lm9mZnNldFdpZHRoKTtcbiAgICAgICF0aGlzLm9wdGlvbnMuaGVpZ2h0ICYmICh0aGlzLm9wdGlvbnMuaGVpZ2h0ID0gdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodCk7IC8vIFJlbW92ZSBib3JkZXIgXG5cbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3RyYW5zcGFyZW50JzsgLy8gU2V0IGJhY2tncm91bmQgaW1hZ2VcblxuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IFwidXJsKFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc3JjLCBcIilcIik7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gXCIwIDBcIjtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IFwiXCIuY29uY2F0KHRoaXMub3B0aW9ucy53aWR0aCAqIHRoaXMub3B0aW9ucy5zdGVwcywgXCJweFwiKTtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kUmVwZWF0ID0gXCJuby1yZXBlYXRcIjtcbiAgICAgIHRoaXMudGwgPSBnc2FwLnRpbWVsaW5lKHtcbiAgICAgICAgcGF1c2VkOiB0cnVlLFxuICAgICAgICByZXBlYXQ6IHRoaXMub3B0aW9ucy5yZXBlYXQgPyAtMSA6IDBcbiAgICAgIH0pO1xuICAgICAgdGhpcy50bC5hZGQoZ3NhcC50byh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5kdXJhdGlvbiAvIDEwMDAsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvblg6IFwiLVwiLmNvbmNhdCh0aGlzLm9wdGlvbnMud2lkdGggKiAodGhpcy5vcHRpb25zLnN0ZXBzIC0gMSksIFwicHhcIiksXG4gICAgICAgIGVhc2U6IFwic3RlcHMoXCIuY29uY2F0KHRoaXMub3B0aW9ucy5zdGVwcyAtIDEsIFwiKVwiKVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHRoaXMudGwucGxheSgwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHtcbiAgICAgIHRoaXMudGwucmV2ZXJzZSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdzcHJpdGVzaGVldCcsXG4gIG9wdGlvbnM6IHtcbiAgICB0cmlnZ2VyOiAnY2xpY2snLFxuICAgIC8vIGxvb3A6IGZhbHNlLFxuICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgICBoZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICBzdGVwczogdW5kZWZpbmVkLFxuICAgIHJlcGVhdDogMFxuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBKdW1wIF0nO1xudmFyIERFQlVHID0gZmFsc2U7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaW5pdGlhbFwiLCB2b2lkIDApO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwic3RhcnRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdpbml0KCknLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5pbml0aWFsID0ge1xuICAgICAgICB5OiBnc2FwLmdldFByb3BlcnR5KHRoaXMuZWxlbWVudCwgJ3knKVxuICAgICAgfTtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ3RoaXMuaW5pdGlhbCcsIHRoaXMuaW5pdGlhbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnc3RhcnQoKScpO1xuICAgICAgZ3NhcC50byh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgeTogdGhpcy5pbml0aWFsLnkgLSAyMCxcbiAgICAgICAgZHVyYXRpb246IDAuNCxcbiAgICAgICAgZWFzZTogJ3Bvd2VyLm91dCg0KSdcbiAgICAgIH0pO1xuICAgICAgZ3NhcC50byh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgeTogdGhpcy5pbml0aWFsLnksXG4gICAgICAgIGR1cmF0aW9uOiAwLjUsXG4gICAgICAgIGRlbGF5OiAwLjUsXG4gICAgICAgIGVhc2U6ICdib3VuY2Uub3V0KDIwKSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdqdW1wJyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdob3ZlcidcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogSGFuZEN1cnNvciBdJztcbnZhciBERUJVRyA9IGZhbHNlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnaW5pdCgpJywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge31cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBlbGVtZW50c1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VuZXJhdGVFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZUVsZW1lbnRzKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdoYW5kLWN1cnNvcicsXG4gIG9wdGlvbnM6IHtcbiAgICB0cmlnZ2VyOiAnbG9hZCdcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogRGVidWdnZXIgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgY29uc29sZS5sb2coJ1xcblxcbicpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRMb2NhbEJvdW5kaW5nQ2xpZW50UmVjdChlbCkge1xuICAgICAgICB2YXIgYSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgYiA9IGVsLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogYS5sZWZ0IC0gYi5sZWZ0LFxuICAgICAgICAgIHRvcDogYS50b3AgLSBiLnRvcCxcbiAgICAgICAgICB3aWR0aDogYS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGEuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9IC8vIENsaWVudCBSZWN0XG5cblxuICAgICAgdmFyIGNsaWVudFJlY3QgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zb2xlLmxvZygnY2xpZW50UmVjdDonLCBjbGllbnRSZWN0KTtcbiAgICAgIHZhciBwYXJlbnRDbGllbnRSZWN0ID0gdGhpcy5lbGVtZW50LnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zb2xlLmxvZygncGFyZW50Q2xpZW50UmVjdDonLCBwYXJlbnRDbGllbnRSZWN0KTtcbiAgICAgIGNvbnNvbGUubG9nKCdsb2NhbCByZWN0OicsIGdldExvY2FsQm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxlbWVudCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnRGVidWdnZXInLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2xvYWQnXG4gIH1cbn0pO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIEV4cGVyaW1lbnRhbCBFZmZlY3RcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGWCA6IFJlbW92ZSBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdvcHRpb25zOicsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAncmVtb3ZlJyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdsb2FkJ1xuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBGYWRlIF0nO1xudmFyIERFQlVHID0gdHJ1ZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScsIHRoaXMub3B0aW9ucyk7IC8vdGhpcy50aW1lbGluZSA9IGdzYXAudGltZWxpbmUoe3BhdXNlZDogdHJ1ZX0pO1xuXG4gICAgICBnc2FwLnNldCh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnc3RhcnQoKScpO1xuICAgICAgZ3NhcC50byh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgZGVsYXk6IHRoaXMub3B0aW9ucy5kZWxheSAvIDEwMDAsXG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnZW5kKCknKTtcbiAgICAgIGdzYXAudG8odGhpcy5lbGVtZW50LCB7XG4gICAgICAgIGRlbGF5OiB0aGlzLm9wdGlvbnMuZGVsYXkgLyAxMDAwLFxuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnZmFkZScsXG4gIG9wdGlvbnM6IHtcbiAgICB0cmlnZ2VyOiAnbG9hZCcsXG4gICAgZGVsYXk6IDEwMFxuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBQYW5ab29tIF0nO1xudmFyIERFQlVHID0gdHJ1ZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBjb25zb2xlLmxvZyhMT0csICdvcHRpb25zOicsIHRoaXMub3B0aW9ucyk7IC8vIFRFTVA6IFhEIEhBQ0tcblxuICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJzsgLy8gR2V0IHN0b3BzXG5cbiAgICAgIHZhciBzdG9wRWxlbWVudHMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2hlcm8tZngtcGFuem9vbS1zdG9wXScpO1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnc3RvcEVsZW1lbnRzOicsIHN0b3BFbGVtZW50cyk7IC8vIFByb2Nlc3Mgc3RvcHNcblxuICAgICAgdGhpcy5zdG9wcyA9IFtdO1xuICAgICAgc3RvcEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBpdGVtLmdldEF0dHJpYnV0ZSgnaGVyby1meC1wYW56b29tLXN0b3AnKTtcbiAgICAgICAgb3B0aW9ucyA9IGhlcm8uZnguRnhTY2FubmVyLmV4dHJhY3RPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgZGVsYXk6IF90aGlzMi5vcHRpb25zLnN0b3BEZWxheVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIHN0b3AgPSB7XG4gICAgICAgICAgZWw6IGl0ZW0sXG4gICAgICAgICAgc2NhbGU6IF90aGlzMi5lbGVtZW50Lm9mZnNldFdpZHRoIC8gaXRlbS5vZmZzZXRXaWR0aCxcbiAgICAgICAgICBsZWZ0OiBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpdGVtKS50cmFuc2Zvcm0uc3BsaXQoJygnKVsxXS5zcGxpdCgnLCcpWzRdKSxcbiAgICAgICAgICB0b3A6IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGl0ZW0pLnRyYW5zZm9ybS5zcGxpdCgnKCcpWzFdLnNwbGl0KCcsJylbNV0pLFxuICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpczIuc3RvcHMucHVzaChzdG9wKTtcblxuICAgICAgICBpdGVtLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICBpdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICB9KTtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ3N0b3BzOicsIHRoaXMuc3RvcHMpOyAvLyBUaW1lbGluZVxuXG4gICAgICB0aGlzLnRpbWVsaW5lID0gZ3NhcC50aW1lbGluZSh7XG4gICAgICAgIHBhdXNlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLnN0b3BzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIF90aGlzMi50aW1lbGluZS50byhfdGhpczIuZWxlbWVudCwge1xuICAgICAgICAgIHNjYWxlOiBpdGVtLnNjYWxlLFxuICAgICAgICAgIHg6IC1pdGVtLmxlZnQgKiBpdGVtLnNjYWxlLFxuICAgICAgICAgIHk6IC1pdGVtLnRvcCAqIGl0ZW0uc2NhbGUsXG4gICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnMCAwJyxcbiAgICAgICAgICBkZWxheTogaW5kZXggPiAwICYmIF90aGlzMi5zdG9wc1tpbmRleCAtIDFdLm9wdGlvbnMuc3RvcCA/IDAgOiBpdGVtLm9wdGlvbnMuZGVsYXkgLyAxMDAwLFxuICAgICAgICAgIGR1cmF0aW9uOiAxLjgsXG4gICAgICAgICAgZWFzZTogJ3Bvd2VyNC5pbk91dCcsXG4gICAgICAgICAgLy8gI1BFUkZPUk1BTkNFLUFORC1CTFVSSU5FU1MgXG4gICAgICAgICAgLy8gU2hvdWxkIGJlIGZhbHNlIHRvIHByZXZlbnQgYmx1cnJpbmVzcyBvbiBzY2FsZXMgc3BlY2lhbGx5IG9uIG1vYmlsZSAoZS5nLiBpUGhvbmUpXG4gICAgICAgICAgLy8gZm9yY2UzRDogdHJ1ZSxcbiAgICAgICAgICBmb3JjZTNEOiBmYWxzZSAvLyBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgIC8vICAgZ3NhcC5zZXQoIHRoaXMudGFyZ2V0cygpWzBdLCB7XG4gICAgICAgICAgLy8gICAgIGZvcmNlM0Q6IGZhbHNlXG4gICAgICAgICAgLy8gICB9KTtcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vcHRpb25zLnN0b3AgJiYgX3RoaXMyLnRpbWVsaW5lLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnRpbWVsaW5lLnBhdXNlKCk7XG5cbiAgICAgICAgICBfdGhpczIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi50aW1lbGluZS5wbGF5KCk7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHRoaXMudGltZWxpbmUucGxheSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdwYW56b29tJyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdsb2FkJyxcbiAgICAvLyBkZWxheTogMTAwMCxcbiAgICBzdG9wRGVsYXk6IDIwMDBcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogWW91VHViZSBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9IC8vIFRFTVA6IFVzZSBGdXNpb25IZWxwZXIgaW5zdGVhZFxuICAvLyBURU1QOiBVc2UgRnVzaW9uSGVscGVyIGluc3RlYWRcblxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiYXBwZW5kSHRtbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRIdG1sKHRhcmdldCwgbWFya3VwKSB7XG4gICAgICB0YXJnZXQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBtYXJrdXApO1xuICAgICAgcmV0dXJuIHRhcmdldC5sYXN0Q2hpbGQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHsvLyBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICd1cGRhdGUoKScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHRoaXMuYXBwZW5kSHRtbCh0aGlzLmVsZW1lbnQsIFwiXFxuICAgICAgPGRpdiBzdHlsZT1cXFwicG9zaXRpb246IHJlbGF0aXZlOyBwYWRkaW5nLXRvcDogXCIuY29uY2F0KDEwODAgLyAxOTIwICogMTAwLCBcIiVcXFwiPlxcbiAgICAgICAgPGlmcmFtZSB3aWR0aD1cXFwiMTAwJVxcXCIgaGVpZ2h0PVxcXCIxMDAlXFxcIiBzcmM9XFxcImh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkL1wiKS5jb25jYXQodGhpcy5vcHRpb25zLnZpZGVvSWQsIFwiP1wiKS5jb25jYXQodGhpcy5vcHRpb25zLmF1dG9wbGF5ID8gJ2F1dG9wbGF5PTEnIDogJycsIFwiXFxcIiBmcmFtZWJvcmRlcj1cXFwiMFxcXCIgIGFsbG93PVxcXCJhY2NlbGVyb21ldGVyOyBhdXRvcGxheTsgZW5jcnlwdGVkLW1lZGlhOyBneXJvc2NvcGU7IHBpY3R1cmUtaW4tcGljdHVyZVxcXCIgYWxsb3dmdWxsc2NyZWVuXFxuICAgICAgICAgICAgICAgIHN0eWxlPVxcXCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgcmlnaHQ6IDA7IGJvdHRvbTogMDsgbGVmdDogMDtcXFwiPjwvaWZyYW1lPlxcbiAgICAgIDwvZGl2PlwiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShGeEJhc2UpO1xuXG5fZGVmaW5lUHJvcGVydHkoX2RlZmF1bHQsIFwibWFuaWZlc3RcIiwge1xuICBpZDogJ3lvdXR1YmUnLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2xvYWQnLFxuICAgIHZpZGVvSWQ6ICdDMERQZHk5OGU0YycsXG4gICAgYXV0b3BsYXk6IHRydWVcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogaWZyYW1lIF0nO1xudmFyIERFQlVHID0gdHJ1ZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH0gLy8gVEVNUDogVXNlIEZ1c2lvbkhlbHBlciBpbnN0ZWFkXG4gIC8vIFRFTVA6IFVzZSBGdXNpb25IZWxwZXIgaW5zdGVhZFxuXG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJhcHBlbmRIdG1sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZEh0bWwodGFyZ2V0LCBtYXJrdXApIHtcbiAgICAgIHRhcmdldC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIG1hcmt1cCk7XG4gICAgICByZXR1cm4gdGFyZ2V0Lmxhc3RDaGlsZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnaW5pdCgpJywgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHsvLyBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICd1cGRhdGUoKScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHRoaXMuYXBwZW5kSHRtbCh0aGlzLmVsZW1lbnQsIFwiXFxuICAgICAgPGRpdiBzdHlsZT1cXFwicG9zaXRpb246IHJlbGF0aXZlOyBwYWRkaW5nLXRvcDogXCIuY29uY2F0KDEwODAgLyAxOTIwICogMTAwLCBcIiVcXFwiPlxcbiAgICAgICAgPGlmcmFtZSB3aWR0aD1cXFwiMTAwJVxcXCIgaGVpZ2h0PVxcXCIxMDAlXFxcIiBzcmM9XFxcIlwiKS5jb25jYXQodGhpcy5vcHRpb25zLnNyYywgXCJcXFwiIGZyYW1lYm9yZGVyPVxcXCIwXFxcIlxcbiAgICAgICAgICAgICAgICBzdHlsZT1cXFwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IGxlZnQ6IDA7XFxcIj48L2lmcmFtZT5cXG4gICAgICA8L2Rpdj5cIikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdpZnJhbWUnLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2xvYWQnLFxuICAgIHNyYzogJ2h0dHBzOi8veGRoZXJvLmNvbS8nXG4gIH1cbn0pO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIEV4cGVyaW1lbnRhbCBFZmZlY3RcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGWCA6IExvdHRpZSBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9IC8vIFRFTVA6IFVzZSBGdXNpb25IZWxwZXIgaW5zdGVhZFxuICAvLyBURU1QOiBVc2UgRnVzaW9uSGVscGVyIGluc3RlYWRcblxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiYXBwZW5kSHRtbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRIdG1sKHRhcmdldCwgbWFya3VwKSB7XG4gICAgICB0YXJnZXQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBtYXJrdXApO1xuICAgICAgcmV0dXJuIHRhcmdldC5sYXN0Q2hpbGQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ3NyYycsICdodHRwczovL3VucGtnLmNvbS9AbG90dGllZmlsZXMvbG90dGllLXBsYXllckBsYXRlc3QvZGlzdC9sb3R0aWUtcGxheWVyLmpzJyk7XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7Ly8gREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAndXBkYXRlKCknKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICBjb25zb2xlLmxvZyhMT0csICdTVEFSVCcpO1xuICAgICAgdGhpcy5hcHBlbmRIdG1sKHRoaXMuZWxlbWVudCwgXCJcXG4gICAgPGxvdHRpZS1wbGF5ZXIgc3JjPVxcXCJcIi5jb25jYXQodGhpcy5vcHRpb25zLnVybCwgXCJcXFwiICBiYWNrZ3JvdW5kPVxcXCJ0cmFuc3BhcmVudFxcXCIgIHNwZWVkPVxcXCIxXFxcIiAgc3R5bGU9XFxcIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7XFxcIiBsb29wIGF1dG9wbGF5ID48L2xvdHRpZS1wbGF5ZXI+XFxuICAgIFwiKSk7XG4gICAgICBjb25zb2xlLmxvZyhMT0csICdTVEFSVCBET05FJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShGeEJhc2UpO1xuXG5fZGVmaW5lUHJvcGVydHkoX2RlZmF1bHQsIFwibWFuaWZlc3RcIiwge1xuICBpZDogJ2xvdHRpZScsXG4gIG9wdGlvbnM6IHtcbiAgICB0cmlnZ2VyOiAnbG9hZCcsXG4gICAgdXJsOiAnaHR0cHM6Ly9hc3NldHMyLmxvdHRpZWZpbGVzLmNvbS9wYWNrYWdlcy9sZjIwXzZhWWxCbC5qc29uJ1xuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBGaXQgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgY29uc29sZS5sb2coTE9HLCAnaW5pdCgpJyk7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLndpZHRoKSB7XG4gICAgICAgIC8vIGNvbnN0IGRpc3BsYXkgPSB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgLy8gdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMub3B0aW9ucy53aWR0aCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmhlaWdodCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScsICd3aWR0aC9oZWlnaHQ6ICcsIHRoaXMub3B0aW9ucy53aWR0aCwgdGhpcy5vcHRpb25zLmhlaWdodCk7IC8vIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcbiAgICAgIH1cblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhlcm8uaGVscGVyLnRocm90dGxlKHRoaXMudXBkYXRlTGF5b3V0LmJpbmQodGhpcyksIDIwMCkpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhlcm8uaGVscGVyLmRlYm91bmNlKHRoaXMudXBkYXRlTGF5b3V0LmJpbmQodGhpcyksIDIwMDApKTtcbiAgICAgIHRoaXMudXBkYXRlTGF5b3V0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge31cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVMYXlvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTGF5b3V0KCkge1xuICAgICAgLy8gaWYgKHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID09ICdub25lJykgcmV0dXJuO1xuICAgICAgLy8gY29uc3QgYmJveCA9IHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgLy8gY29uc3QgYXZhaWxXaWR0aCA9IGJib3gud2lkdGg7XG4gICAgICAvLyBjb25zdCBhdmFpbEhlaWdodCA9IGJib3guaGVpZ2h0O1xuICAgICAgLy8gY29uc29sZS5sb2coTE9HLCAnYXZhaWxXaWR0aCcsIGF2YWlsV2lkdGgpO1xuICAgICAgLy8gY29uc29sZS5sb2coTE9HLCAnYXZhaWxIZWlnaHQnLCBhdmFpbEhlaWdodCk7XG4gICAgICAvLyBsZXQgc2NhbGVYID0gYXZhaWxXaWR0aCAvIHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICAgIC8vIGxldCBzY2FsZVkgPSBhdmFpbEhlaWdodCAvIHRoaXMub3B0aW9ucy5oZWlnaHQ7XG4gICAgICAvLyBsZXQgc2NhbGUgPSBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhMT0csICdzY2FsZScsIHNjYWxlKTtcbiAgICAgIC8vIHNjYWxlID0gKHNjYWxlID4gMSkgPyAxIDogc2NhbGU7XG4gICAgICAvLyB0aGlzLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7c2NhbGV9KWA7XG4gICAgICBpZiAodGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPT0gJ25vbmUnKSByZXR1cm47XG4gICAgICB2YXIgYXZhaWxXaWR0aCA9IHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgdmFyIGF2YWlsSGVpZ2h0ID0gdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc29sZS5sb2coTE9HLCAnYXZhaWxXaWR0aCcsIGF2YWlsV2lkdGgpO1xuICAgICAgY29uc29sZS5sb2coTE9HLCAnYXZhaWxIZWlnaHQnLCBhdmFpbEhlaWdodCk7XG4gICAgICB2YXIgc2NhbGVYID0gYXZhaWxXaWR0aCAvIHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICAgIHZhciBzY2FsZVkgPSBhdmFpbEhlaWdodCAvIHRoaXMub3B0aW9ucy5oZWlnaHQ7XG4gICAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSk7XG4gICAgICBjb25zb2xlLmxvZyhMT0csICdzY2FsZScsIHNjYWxlKTtcbiAgICAgIHNjYWxlID0gc2NhbGUgPiAxID8gMSA6IHNjYWxlOyAvLyB0aGlzLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gYDAgMGA7XG5cbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlKFwiLmNvbmNhdChzY2FsZSwgXCIpXCIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdmaXQnLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2xvYWQnLFxuICAgIHdpZHRoOiBudWxsLFxuICAgIC8vIHJhdyB3aWR0aFxuICAgIGhlaWdodDogbnVsbCAvLyByYXcgaGVpZ2h0XG5cbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogdGV4dC1pbnB1dCBdJztcbnZhciBERUJVRyA9IGZhbHNlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImlucHV0XCIsIHZvaWQgMCk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9IC8vIFRFTVA6IFVzZSBGdXNpb25IZWxwZXIgaW5zdGVhZFxuICAvLyBURU1QOiBVc2UgRnVzaW9uSGVscGVyIGluc3RlYWRcblxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiYXBwZW5kSHRtbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRIdG1sKHRhcmdldCwgbWFya3VwKSB7XG4gICAgICB0YXJnZXQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBtYXJrdXApO1xuICAgICAgcmV0dXJuIHRhcmdldC5sYXN0Q2hpbGQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdpbml0KCknLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdmFyIGlucHV0ID0gJzxpbnB1dCBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBsZWZ0OiAwOyB3aWR0aDogMTAwJTsgb3V0bGluZTogbm9uZTsgYm9yZGVyOiBub25lOyBwYWRkaW5nOiA0cHggMTRweDsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XCIvPic7XG4gICAgICB0aGlzLmFwcGVuZEh0bWwodGhpcy5lbGVtZW50LCBpbnB1dCk7XG4gICAgICB0aGlzLmlucHV0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc291cmNlKSB7XG4gICAgICAgIHBsYXllci5kYXRhLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChrZXkgPT09IF90aGlzMi5vcHRpb25zLnNvdXJjZSkge1xuICAgICAgICAgICAgX3RoaXMyLmlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICBwbGF5ZXIuZGF0YS5zZXQoX3RoaXMyLm9wdGlvbnMuc291cmNlLCBldnQuY3VycmVudFRhcmdldC52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBfdGhpczIuZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgndHlwZScsIHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIHZhbHVlOiBldnQuY3VycmVudFRhcmdldC52YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge31cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICd0ZXh0LWlucHV0JyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdsb2FkJyxcbiAgICBzb3VyY2U6ICcnXG4gIH1cbn0pO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIEV4cGVyaW1lbnRhbCBFZmZlY3RcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGWCA6IHJlcGVhdC1ncmlkIF0nO1xudmFyIERFQlVHID0gZmFsc2U7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaW5wdXRcIiwgdm9pZCAwKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH0gLy8gVEVNUDogVXNlIEZ1c2lvbkhlbHBlciBpbnN0ZWFkXG4gIC8vIFRFTVA6IFVzZSBGdXNpb25IZWxwZXIgaW5zdGVhZFxuXG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJhcHBlbmRIdG1sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZEh0bWwodGFyZ2V0LCBtYXJrdXApIHtcbiAgICAgIHRhcmdldC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIG1hcmt1cCk7XG4gICAgICByZXR1cm4gdGFyZ2V0Lmxhc3RDaGlsZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScsIHRoaXMub3B0aW9ucyk7IC8vLS0tXG4gICAgICAvLyBDdXN0b20gQ1NTXG5cbiAgICAgIHZhciBjc3MgPSBcIlxcbiAgICAgIC5yZXBlYXQtZ3JpZCA+ICoge1xcbiAgICAgICAgcG9zaXRpb246IHN0YXRpYyAhaW1wb3J0YW50O1xcbiAgICAgIH1cIjtcbiAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpOyAvLy0tLVxuICAgICAgLy8gRXh0cmFjdCBncmlkIG1ldGEgZGF0YSBmcm9tIFhEXG5cbiAgICAgIHZhciBncmlkTWV0YURhdGEgPSBKU09OLnBhcnNlKGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd4ZC1yZXBlYXQtZ3JpZCcpKSk7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdSRVBFQVRfR1JJRF9EQVRBOicsIGdyaWRNZXRhRGF0YSk7IC8vLS0tXG4gICAgICAvLyBQcmVwYXJlIGdyaWRcblxuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3JlcGVhdC1ncmlkJyk7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBncmlkTWV0YURhdGEud2lkdGggKyAncHgnO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IGdyaWRNZXRhRGF0YS5udW1Sb3dzICogKGdyaWRNZXRhRGF0YS5jZWxsSGVpZ2h0ICsgZ3JpZE1ldGFEYXRhLnBhZGRpbmdZKSArICdweCc7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUub3ZlcmZsb3dYID0gJ2hpZGRlbic7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nOyAvLyB0aGlzLmVsZW1lbnQuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjREREJztcbiAgICAgIC8vLS0tXG4gICAgICAvLyBFeHRyYWN0IHRlbXBsYXRlIGFuZCByZW1vdmUgYWxsIGl0ZW1zXG5cbiAgICAgIHZhciBmaXJzdCA9ICQodGhpcy5lbGVtZW50KS5maW5kKCcuaXRlbScpLmZpcnN0KCk7XG4gICAgICBmaXJzdFswXS5zdHlsZS53aWR0aCA9IGdyaWRNZXRhRGF0YS5jZWxsV2lkdGggKyAncHgnO1xuICAgICAgZmlyc3RbMF0uc3R5bGUuaGVpZ2h0ID0gZ3JpZE1ldGFEYXRhLmNlbGxIZWlnaHQgKyAncHgnO1xuICAgICAgZmlyc3RbMF0uc3R5bGUubWFyZ2luQm90dG9tID0gZ3JpZE1ldGFEYXRhLnBhZGRpbmdZICsgJ3B4JztcbiAgICAgIGZpcnN0WzBdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIC1ncmlkTWV0YURhdGEub2Zmc2V0WCArICdweCwgJyArIC1ncmlkTWV0YURhdGEub2Zmc2V0WSArICdweCknOyAvLy0tLVxuICAgICAgLy8gUG9wdWxhdGVcblxuICAgICAgdmFyIHBvcHVsYXRlID0gZnVuY3Rpb24gcG9wdWxhdGUodmFsdWUpIHtcbiAgICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAncG9wdWxhdGUnLCB2YWx1ZSk7XG4gICAgICAgICQoX3RoaXMyLmVsZW1lbnQpLmZpbmQoJy5pdGVtJykucmVtb3ZlKCk7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IGZpcnN0LmNsb25lKCk7IC8vZWxlbWVudFswXS5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkIGJsdWUnO1xuICAgICAgICAgIC8vIEZvbGxvd2luZyBzdHVudCBpcyBuZWVkZWQgYmVjYXVzZSBvZmZzZXQgb2YgZWxlbWVudHMgKHdpdGhvdXQgc3R1bnQgdXNlciBtaWdodCBjbGljayBvbiBhIGRpZmZlcmVudCBlbGVtZW50KVxuXG4gICAgICAgICAgZWxlbWVudFswXS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgIGVsZW1lbnRbMF0uc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgZWxlbWVudC5maW5kKCcqJykuY3NzKHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdhbGwnXG4gICAgICAgICAgfSk7IC8vIGVsZW1lbnQuZmluZCgnc3ZnLmNvdW50cnkgdGV4dCB0c3BhbicpWzBdLnRleHRDb250ZW50ID0gaXRlbS5jb3VudHJ5O1xuICAgICAgICAgIC8vIGVsZW1lbnQuZmluZCgnc3ZnLmNpdHkgdGV4dCB0c3BhbicpWzBdLnRleHRDb250ZW50ID0gaXRlbS5jaXR5O1xuICAgICAgICAgIC8vIHZhciBpbWFnZSA9IGVsZW1lbnQuZmluZCgnLmltYWdlJylbMF07XG4gICAgICAgICAgLy9pbWFnZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKCcraXRlbS5pbWFnZSsnKSc7XG4gICAgICAgICAgLy9pbWFnZS5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9ICdjb250YWluJztcbiAgICAgICAgICAvLyBpbWFnZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIGl0ZW0uaW1hZ2UpXG4gICAgICAgICAgLy8gZWxlbWVudC5maW5kKCcuc3BlY2lhbCcpWzBdLnN0eWxlLmRpc3BsYXkgPSBpdGVtLnNwZWNpYWwgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgICAgICAgIC8vIFNhdmUgZGF0YSBvbiBpdGVtIGVsZW1lbnRcblxuICAgICAgICAgIGVsZW1lbnRbMF0uZGF0YSA9IHJlY29yZDsgLy8gZWxlbWVudFswXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIC8vICAgd2luZG93LmRhdGEuY3VycmVudCA9IGV2dC5jdXJyZW50VGFyZ2V0LnRtcERhdGE7XG4gICAgICAgICAgLy8gICBwbGF5ZXIubG9hZFNjZW5lKCdkZXRhaWwnKTtcbiAgICAgICAgICAvLyAgIHdpbmRvdy5kYXRhLnVwZGF0ZURldGFpbCgpO1xuICAgICAgICAgIC8vIH0pO1xuXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHJlY29yZC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIHZhciBfdmFsdWUgPSByZWNvcmRba2V5XTsgLy8gY29uc29sZS5sb2coa2V5LCAnID0+ICcsIHZhbHVlKTtcblxuICAgICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBlbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3IoJy4nICsga2V5KTtcblxuICAgICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBQbGFjZWhvbGRlciBpcyBpbWFnZVxuICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlci5ub2RlTmFtZSA9PSAnSU1HJykge1xuICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIuc3JjID0gX3ZhbHVlO1xuICAgICAgICAgICAgICAgIH0gLy8gUGxhY2Vob2xkZXIgaXMgdGV4dFxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlci5xdWVyeVNlbGVjdG9yKCd0ZXh0IHRzcGFuJykudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIuaW5uZXJUZXh0ID0gX3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ3NhcC50byhlbGVtZW50WzBdLCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgZGVsYXk6IGluZGV4ICogMC4xLFxuICAgICAgICAgICAgZHVyYXRpb246IDAuNlxuICAgICAgICAgIH0pO1xuICAgICAgICAgICQoX3RoaXMyLmVsZW1lbnQpLmFwcGVuZChlbGVtZW50KTtcbiAgICAgICAgICBoZXJvLmZ4LkZ4U2Nhbm5lci5zY2FuKF90aGlzMi5lbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9OyAvLy0tLVxuICAgICAgLy8gR2V0IGRhdGFcblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZSkge1xuICAgICAgICBwbGF5ZXIuZGF0YS5vbignY2hhbmdlJywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSBfdGhpczIub3B0aW9ucy5zb3VyY2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMuaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHBvcHVsYXRlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge31cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAncmVwZWF0LWdyaWQnLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2xvYWQnLFxuICAgIHNvdXJjZTogJydcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuaW1wb3J0IE5hbm9FdmVudHMgZnJvbSAnLi4vLi4vLi4vbGlicy9uYW5vZXZlbnRzJztcbnZhciBMT0cgPSAnWyBQbHVnaW5CYXNlIF0nO1xudmFyIERFQlVHID0gdHJ1ZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfTmFub0V2ZW50cykge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9OYW5vRXZlbnRzKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdChzY2VuZSwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuY2FsbCh0aGlzKSk7XG4gICAgX3RoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICBfdGhpcy5wbGF5ZXIgPSBzY2VuZS5wbGF5ZXI7XG4gICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHRoaXMubWFuaWZlc3Qub3B0aW9ucywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oTmFub0V2ZW50cyk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuLy8gRXhwZXJpbWVudGFsIFBsdWdpblxuaW1wb3J0IFBsdWdpbkJhc2UgZnJvbSAnLi4vUGx1Z2luQmFzZSc7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vLi4vQ29uc3QnO1xudmFyIExPRyA9ICdbIFBsdWdpbiA6IFZpc3VhbERlYnVnZ2VyIF0nO1xudmFyIERFQlVHID0gZmFsc2U7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BsdWdpbkJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfUGx1Z2luQmFzZSk7XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBudWxsLCBbe1xuICAgIGtleTogXCJtYW5pZmVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYW5pZmVzdCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiAndmlzdWFsRGVidWdnZXInLFxuICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIF90aGlzLm1hbmlmZXN0ID0gX3RoaXMuY29uc3RydWN0b3IubWFuaWZlc3QoKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScpO1xuICAgICAgdGhpcy5zY2VuZS5vbihDb25zdC5TQ0VORV9QUkVfUkVBRFksIHRoaXMub25fc2NlbmVfcHJlUmVhZHkuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLnNjZW5lLm9uKENvbnN0LlNDRU5FX1JFQURZLCB0aGlzLm9uX3NjZW5lX3JlYWR5LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBvbl9zY2VuZV9wcmVSZWFkeVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25fc2NlbmVfcHJlUmVhZHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25fc2NlbmVfcHJlUmVhZHkoKSB7fVxuICAgIC8qKlxuICAgICAqIG9uX3NjZW5lX3JlYWR5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbl9zY2VuZV9yZWFkeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbl9zY2VuZV9yZWFkeSgpIHtcbiAgICAgIHZhciBjbG9uZSA9IHRoaXMuc2NlbmUuY29udGVudC5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgY2xvbmUuc2V0QXR0cmlidXRlKCdzdHlsZScsIHRoaXMuc2NlbmUuY29udGVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpO1xuICAgICAgY2xvbmUuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCByZ2JhKDAsMCwwLC4yKSc7XG4gICAgICBjbG9uZS5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gICAgICBjbG9uZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgdGhpcy5zY2VuZS5jb250ZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oUGx1Z2luQmFzZSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuLy8gRXhwZXJpbWVudGFsIFBsdWdpblxuaW1wb3J0IFBsdWdpbkJhc2UgZnJvbSAnLi4vUGx1Z2luQmFzZSc7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vLi4vQ29uc3QnO1xudmFyIExPRyA9ICdbIFBsdWdpbiA6IFBhbm9yYW1hIF0nO1xudmFyIERFQlVHID0gdHJ1ZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGx1Z2luQmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9QbHVnaW5CYXNlKTtcblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIG51bGwsIFt7XG4gICAga2V5OiBcIm1hbmlmZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hbmlmZXN0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6ICdwYW5vcmFtYScsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBzcGVlZDogMVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgX3RoaXMubWFuaWZlc3QgPSBfdGhpcy5jb25zdHJ1Y3Rvci5tYW5pZmVzdCgpO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF90aGlzLm1vdXNlWDtcbiAgICBfdGhpcy5sYXN0U2Nyb2xsVG8gPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnaW5pdCgpJyk7XG4gICAgICB0aGlzLnNjZW5lLm9uKENvbnN0LlNDRU5FX1BSRV9SRUFEWSwgdGhpcy5vbl9zY2VuZV9wcmVSZWFkeS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuc2NlbmUub24oQ29uc3QuU0NFTkVfUkVBRFksIHRoaXMub25fc2NlbmVfcmVhZHkuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG9uX3NjZW5lX3ByZVJlYWR5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbl9zY2VuZV9wcmVSZWFkeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbl9zY2VuZV9wcmVSZWFkeSgpIHtcbiAgICAgIC8vIFByZXBhcmUgc2NlbmVcbiAgICAgIHRoaXMuc2NlbmUuZWxlbWVudC5zdHlsZS5vdmVyZmxvd1ggPSAnc2Nyb2xsJztcbiAgICAgIHRoaXMuc2NlbmUuY29udGVudC5zdHlsZS5vdmVyZmxvdyA9ICd1bnNldCc7IC8vIC8vIFR3ZWFrIGNvbnRlbnQgY29udGFpbmVyIHRvIGdldCByZWFsIHdpZHRoXG4gICAgICAvLyAvLyBzY2VuZS5jb250ZW50LnN0eWxlLndpZHRoID0gJ2F1dG8nO1xuICAgICAgLy8gc2NlbmUuY29udGVudC5zdHlsZS5yaWdodCA9ICd1bnNldCc7XG4gICAgICAvLyAvLyBQcmV2ZW50IGhpc3RvcnkgYmFjayB3aGVuIHNjcm9sbGluZyB0byBsZWZ0IG9uIHZpZXdwb3J0XG4gICAgICAvLyAvLyAjVE9ETzogTm90IHByZXZlbnRpbmcgaW4gRWRnZVxuICAgICAgLy8gc2NlbmUuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAvLyAgIGlmIChldnQuY3VycmVudFRhcmdldC5zY3JvbGxMZWZ0IDw9IDAgJiYgZXZ0LmRlbHRhWCA8IDApICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIC8vIH0sIHtwYXNzaXZlOiBmYWxzZX0pO1xuICAgICAgLy8gI1RPRE86IERFQ0lERSBPTiBUSFJPVFRMRVxuXG4gICAgICB0aGlzLnNjZW5lLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGVyby5GdXNpb25IZWxwZXIudGhyb3R0bGUodGhpcy5vbl9zY2VuZV9tb3VzZU1vdmUuYmluZCh0aGlzKSwgNTApKTsgLy8gMjBmcHNcblxuICAgICAgdGhpcy5zY2VuZS5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbl9zY2VuZV9jbGljay5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogb25fc2NlbmVfcmVhZHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uX3NjZW5lX3JlYWR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uX3NjZW5lX3JlYWR5KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnb25fc2NlbmVfcmVhZHkoKScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBvbl9zY2VuZV9tb3VzZU1vdmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uX3NjZW5lX21vdXNlTW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbl9zY2VuZV9tb3VzZU1vdmUoZXZ0KSB7XG4gICAgICB0aGlzLm1vdXNlWCA9IGV2dC5jbGllbnRYIC0gdGhpcy5zY2VuZS5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG9uX3NjZW5lX2NsaWNrXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbl9zY2VuZV9jbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbl9zY2VuZV9jbGljayhldnQpIHtcbiAgICAgIC8vIEJhaWwgaWYgbW91c2UgaXMgb24gaW50ZXJhY3RpdmUgZWxlbWVudHNcbiAgICAgIGlmIChldnQudGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaGVyby1pbnRlcmFjdGl2ZScpKSByZXR1cm47IC8vIEJhaWwgaWYgYWxyZWFkeSBtb3Zpbmcvc2Nyb2xsaW5nXG5cbiAgICAgIGlmIChnc2FwLmlzVHdlZW5pbmcodGhpcy5zY2VuZS5lbGVtZW50KSkgcmV0dXJuO1xuICAgICAgdmFyIHNjZW5lID0gdGhpcy5zY2VuZTsgLy8gRGV0ZXJtaW5lIGRpcmVjdGlvblxuXG4gICAgICB2YXIgbWluU2Nyb2xsVG8gPSAwO1xuICAgICAgdmFyIG1heFNjcm9sbFRvID0gTWF0aC5yb3VuZChzY2VuZS5jb250ZW50LnNjcm9sbFdpZHRoICogc2NlbmUuc2NhbGUgLSBzY2VuZS5lbGVtZW50LmNsaWVudFdpZHRoKTtcbiAgICAgIHZhciBkaXIgPSB0aGlzLm1vdXNlWCAtIHNjZW5lLmVsZW1lbnQuY2xpZW50V2lkdGggLyAyID4gMCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICBkaXIgPSBzY2VuZS5lbGVtZW50LnNjcm9sbExlZnQgPD0gbWluU2Nyb2xsVG8gPyAncmlnaHQnIDogZGlyO1xuICAgICAgZGlyID0gc2NlbmUuZWxlbWVudC5zY3JvbGxMZWZ0ID49IG1heFNjcm9sbFRvID8gJ2xlZnQnIDogZGlyO1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnZGlyOicsIGRpcik7IC8vLS0tXG4gICAgICAvLyBzdGVwID0gc2NlbmUgd2lkdGhcbiAgICAgIC8vIHZhciBjdXJyZW50SW5kZXggPSBNYXRoLnJvdW5kKHNjZW5lLmVsZW1lbnQuc2Nyb2xsTGVmdC8oc2NlbmUuZGF0YS53aWR0aCAqIHNjZW5lLnNjYWxlKSk7XG4gICAgICAvLyB2YXIgc2Nyb2xsVG8gPSAoKGRpcj09J2xlZnQnKSA/IGN1cnJlbnRJbmRleC0xIDogY3VycmVudEluZGV4KzEpICogKHNjZW5lLmRhdGEud2lkdGggKiBzY2VuZS5zY2FsZSk7XG4gICAgICAvLyBzY3JvbGxUbyA9IChzY3JvbGxUbyA8PSBtaW5TY3JvbGxUbykgPyAnMCcgOiBzY3JvbGxUbztcbiAgICAgIC8vIHNjcm9sbFRvID0gKHNjcm9sbFRvID4gbWF4U2Nyb2xsVG8pID8gbWF4U2Nyb2xsVG8gOiBzY3JvbGxUbztcbiAgICAgIC8vLS0tXG4gICAgICAvLyBzdGVwID0gY3VzdG9tIHN0b3BzXG5cbiAgICAgIHZhciBzdG9wcyA9IHRoaXMub3B0aW9ucy5zdG9wcztcbiAgICAgIGlmICghc3RvcHMpIGNvbnNvbGUuZXJyb3IoTE9HLCAnbWlzc2luZyBvcHRpb25zIFwic3RvcHNcIicpO1xuICAgICAgc3RvcHMgPSBzdG9wcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoeCAqIHNjZW5lLnNjYWxlKTtcbiAgICAgIH0pO1xuICAgICAgc3RvcHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICB9KTtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ3N0b3BzJywgc3RvcHMpO1xuICAgICAgdmFyIGN1cnJlbnRTY3JvbGxDZW50ZXIgPSBNYXRoLnJvdW5kKHNjZW5lLmVsZW1lbnQuc2Nyb2xsTGVmdCArIHNjZW5lLmVsZW1lbnQuY2xpZW50V2lkdGggLyAyIC0gKHNjZW5lLmVsZW1lbnQuY2xpZW50V2lkdGggLSBzY2VuZS5jb250ZW50LmNsaWVudFdpZHRoICogc2NlbmUuc2NhbGUpIC8gMik7IC8vIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2N1cnJlbnRTY3JvbGxDZW50ZXInLCBjdXJyZW50U2Nyb2xsQ2VudGVyKTtcblxuICAgICAgdmFyIHNjcm9sbFRvO1xuICAgICAgdmFyIHN0b3AgPSAwO1xuXG4gICAgICBpZiAoZGlyID09ICdsZWZ0Jykge1xuICAgICAgICAvLyBGaW5kIG5leHQgc21hbGxlciBzdG9wIChyZWxhdGl2ZSB0byBjdXJyZW50IHNjcm9sbCBjZW50ZXIpXG4gICAgICAgIHZhciBzdG9wc1JldmVyc2UgPSBzdG9wcy5zbGljZSgwKS5yZXZlcnNlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9wc1JldmVyc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IHN0b3BzUmV2ZXJzZVtpXTtcblxuICAgICAgICAgIGlmIChpdGVtIDwgY3VycmVudFNjcm9sbENlbnRlcikge1xuICAgICAgICAgICAgc3RvcCA9IGl0ZW07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZpbmQgbmV4dCBoaWdoZXIgc3RvcCAocmVsYXRpdmUgdG8gY3VycmVudCBzY3JvbGwgY2VudGVyKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBzdG9wc1tpXTtcblxuICAgICAgICAgIGlmIChpdGVtID4gY3VycmVudFNjcm9sbENlbnRlciArIDEpIHtcbiAgICAgICAgICAgIHN0b3AgPSBpdGVtO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENhbGN1bGF0ZSBzY3JvbGwgbmV3IHBvc2l0aW9uXG5cblxuICAgICAgc2Nyb2xsVG8gPSBNYXRoLmZsb29yKHN0b3AgLSBzY2VuZS5lbGVtZW50LmNsaWVudFdpZHRoIC8gMiArIChzY2VuZS5lbGVtZW50LmNsaWVudFdpZHRoIC0gc2NlbmUuY29udGVudC5jbGllbnRXaWR0aCAqIHNjZW5lLnNjYWxlKSAvIDIpO1xuICAgICAgc2Nyb2xsVG8gPSBzY3JvbGxUbyA8PSBtaW5TY3JvbGxUbyA/ICcwJyA6IHNjcm9sbFRvO1xuICAgICAgc2Nyb2xsVG8gPSBzY3JvbGxUbyA+IG1heFNjcm9sbFRvID8gbWF4U2Nyb2xsVG8gOiBzY3JvbGxUbzsgLy8gREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnc2Nyb2xsVG8nLCBzY3JvbGxUbyk7XG4gICAgICAvLyBEdXJhdGlvbiByZWxhdGl2ZSB0byBkaXN0YW5jZVxuXG4gICAgICB2YXIgZHVyYXRpb24gPSBNYXRoLmFicyh0aGlzLmxhc3RTY3JvbGxUbyAtIHNjcm9sbFRvKSAvIDEyMDAgLyB0aGlzLm9wdGlvbnMuc3BlZWQ7XG4gICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uIDwgLjIgPyAuMiA6IGR1cmF0aW9uOyAvLyBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdzcGVlZCcsIHRoaXMub3B0aW9ucy5zcGVlZCk7XG4gICAgICAvLyBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdkdXJhdGlvbicsIGR1cmF0aW9uKTtcbiAgICAgIC8vIFJlbWVtYmVyXG5cbiAgICAgIHRoaXMubGFzdFNjcm9sbFRvID0gc2Nyb2xsVG87IC8vIFR3ZWVuICAgIFxuXG4gICAgICBnc2FwLmlzVHdlZW5pbmcoc2NlbmUuZWxlbWVudCkgJiYgZ3NhcC5raWxsVHdlZW5zT2Yoc2NlbmUuZWxlbWVudCk7XG4gICAgICBnc2FwLnRvKHNjZW5lLmVsZW1lbnQsIHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBlYXNlOiAncG93ZXI0LmluT3V0JyxcbiAgICAgICAgc2Nyb2xsTGVmdDogc2Nyb2xsVG8sXG4gICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgLy8gdXBkYXRlQ3Vyc29yRGlyKCk7XG4gICAgICAgICAgLy8gUHJvcGFnYXRlIGN1c3RvbV9zbGlkZV9hY3RpdmVcbiAgICAgICAgICBzY2VuZS5lbWl0KCdjdXN0b21fc2xpZGVfYWN0aXZlJywge1xuICAgICAgICAgICAgaW5kZXg6IHN0b3BzLmluZGV4T2Yoc3RvcCksXG4gICAgICAgICAgICBzY3JvbGxUbzogc2Nyb2xsVG9cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShQbHVnaW5CYXNlKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImltcG9ydCB0aHJvdHRsZSBmcm9tICdsb2Rhc2gudGhyb3R0bGUnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC5kZWJvdW5jZSc7XG5pbXBvcnQgSGVscGVyIGZyb20gJy4vaGVyby9oZWxwZXIvSGVscGVyLmpzJztcbmltcG9ydCBIZXJvIGZyb20gJy4vaGVyby9jb3JlL0hlcm8nOyAvLyBpbXBvcnQge0Z1c2lvbkhlbHBlcn0gZnJvbSAnLi9oZXJvL2NvcmUvRnVzaW9uSGVscGVyJztcblxuaW1wb3J0IEZ4U2Nhbm5lciBmcm9tICcuL2hlcm8vZngvRnhTY2FubmVyJztcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi9oZXJvL2Z4L0Z4QmFzZSc7IC8vIEVmZmVjdHNcblxuaW1wb3J0IEdsaXRjaCBmcm9tICcuL2hlcm8vZngvY29yZS9HbGl0Y2gnO1xuaW1wb3J0IE1hZ25ldCBmcm9tICcuL2hlcm8vZngvY29yZS9NYWduZXQnO1xuaW1wb3J0IFNlcXVlbmNlIGZyb20gJy4vaGVyby9meC9jb3JlL1NlcXVlbmNlJztcbmltcG9ydCBBcHBlYXIgZnJvbSAnLi9oZXJvL2Z4L2NvcmUvQXBwZWFyJztcbmltcG9ydCBIaWRlIGZyb20gJy4vaGVyby9meC9jb3JlL0hpZGUnO1xuaW1wb3J0IEludmlzaWJsZSBmcm9tICcuL2hlcm8vZngvY29yZS9JbnZpc2libGUnO1xuaW1wb3J0IE5vUG9pbnRlckV2ZW50cyBmcm9tICcuL2hlcm8vZngvY29yZS9Ob1BvaW50ZXJFdmVudHMnO1xuaW1wb3J0IFBhcmFsbGF4IGZyb20gJy4vaGVyby9meC9jb3JlL1BhcmFsbGF4JztcbmltcG9ydCBUeXBlQW5pbWF0aW9uIGZyb20gJy4vaGVyby9meC90eXBlL1R5cGVBbmltYXRpb24nO1xuaW1wb3J0IFR5cGVTcGluIGZyb20gJy4vaGVyby9meC90eXBlL1R5cGVTcGluJztcbmltcG9ydCBQYXJ0aWNsZXMgZnJvbSAnLi9oZXJvL2Z4L2V4cGVyaW1lbnRhbC9QYXJ0aWNsZXMnO1xuaW1wb3J0IFNwcml0ZXNoZWV0IGZyb20gJy4vaGVyby9meC9leHBlcmltZW50YWwvU3ByaXRlc2hlZXQnO1xuaW1wb3J0IEp1bXAgZnJvbSAnLi9oZXJvL2Z4L2V4cGVyaW1lbnRhbC9KdW1wJztcbmltcG9ydCBIYW5kQ3Vyc29yIGZyb20gJy4vaGVyby9meC9leHBlcmltZW50YWwvSGFuZEN1cnNvcic7XG5pbXBvcnQgRGVidWdnZXIgZnJvbSAnLi9oZXJvL2Z4L2V4cGVyaW1lbnRhbC9EZWJ1Z2dlcic7IC8vIGltcG9ydCBHbGl0Y2hDYW52YXMgZnJvbSAnLi9oZXJvL2Z4L2V4cGVyaW1lbnRhbC9HbGl0Y2hDYW52YXMnO1xuLy8gaW1wb3J0IEdsaXRjaEVhc2VsIGZyb20gJy4vaGVyby9meC9leHBlcmltZW50YWwvR2xpdGNoRWFzZWwnO1xuLy8gaW1wb3J0IEdsaXRjaEFwcGVhciBmcm9tICcuL2hlcm8vZngvZXhwZXJpbWVudGFsL0dsaXRjaEFwcGVhcic7XG4vLyBpbXBvcnQgR2xpdGNoSW5PdXQgZnJvbSAnLi9oZXJvL2Z4L2V4cGVyaW1lbnRhbC9HbGl0Y2hJbk91dCc7XG5cbmltcG9ydCBSZW1vdmUgZnJvbSAnLi9oZXJvL2Z4L2V4cGVyaW1lbnRhbC9SZW1vdmUnO1xuaW1wb3J0IEZhZGUgZnJvbSAnLi9oZXJvL2Z4L2V4cGVyaW1lbnRhbC9GYWRlJztcbmltcG9ydCBQYW5ab29tIGZyb20gJy4vaGVyby9meC9leHBlcmltZW50YWwvUGFuWm9vbSc7XG5pbXBvcnQgWW91VHViZSBmcm9tICcuL2hlcm8vZngvY29tcG9uZW50cy9Zb3VUdWJlJztcbmltcG9ydCBJRnJhbWUgZnJvbSAnLi9oZXJvL2Z4L2NvbXBvbmVudHMvSUZyYW1lJztcbmltcG9ydCBMb3R0aWUgZnJvbSAnLi9oZXJvL2Z4L2NvbXBvbmVudHMvTG90dGllJztcbmltcG9ydCBGaXQgZnJvbSAnLi9oZXJvL2Z4L2NvcmUvRml0JzsgLy8gRGF0YSBkcml2ZW5cblxuaW1wb3J0IFRleHRJbnB1dCBmcm9tICcuL2hlcm8vZngvZXhwZXJpbWVudGFsX2RhdGFfZHJpdmVuL1RleHRJbnB1dCc7XG5pbXBvcnQgUmVwZWF0R3JpZCBmcm9tICcuL2hlcm8vZngvZXhwZXJpbWVudGFsX2RhdGFfZHJpdmVuL1JlcGVhdEdyaWQnO1xuaW1wb3J0IFZpc3VhbERlYnVnZ2VyIGZyb20gJy4vZnVzaW9uL3BsdWdpbnMvd2lwL1Zpc3VhbERlYnVnZ2VyJztcbmltcG9ydCBQYW5vcmFtYSBmcm9tICcuL2Z1c2lvbi9wbHVnaW5zL3dpcC9QYW5vcmFtYSc7XG5pbXBvcnQgJy4uL3N0eWxlL2hlcm8uc2Nzcyc7XG5cbnZhciB2ZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcblxuY29uc29sZS5sb2coJ1sgSGVybyBdJywgJ1ZFUlNJT04nLCB2ZXJzaW9uKTsgLy8gR3NhcCBEZWZhdWx0c1xuXG5nc2FwLmRlZmF1bHRzKHtcbiAgZWFzZTogXCJwb3dlcjIuaW5PdXRcIixcbiAgZHVyYXRpb246IDAuNVxufSk7XG5nc2FwLmNvbmZpZyh7XG4gIGZvcmNlM0Q6IHRydWVcbn0pOyAvLyBHbG9iYWwgSGVybyBpbnN0YW5jZVxuXG53aW5kb3cuaGVybyA9IG5ldyBIZXJvKCk7IC8vIFVzZSBIZXJvIGluc3RhbmNlIGFzIG5hbWVzcGFjZSBmb3IgYWxsIGNsYXNzZXNcblxuT2JqZWN0LmFzc2lnbih3aW5kb3cuaGVybywge1xuICAvLyBGdXNpb25IZWxwZXIsIC8vIE1PVkVEIFRPIEZVU0lPTlxuICAvLyAjVE9ETzogRGVjaWRlIGJldHdlZW4gRnVzaW9uSGVscGVyLnRocm90dGxlIGFuZCBoZWxwZXIudGhyb3R0bGUgKGxvZGFzaClcbiAgaGVscGVyOiB7XG4gICAgdGhyb3R0bGU6IHRocm90dGxlLFxuICAgIGRlYm91bmNlOiBkZWJvdW5jZSxcbiAgICBhcHBlbmRIdG1sOiBIZWxwZXIuYXBwZW5kSHRtbFxuICB9LFxuICBwbHVnaW5zOiB7XG4gICAgUGFub3JhbWE6IFBhbm9yYW1hLFxuICAgIFZpc3VhbERlYnVnZ2VyOiBWaXN1YWxEZWJ1Z2dlclxuICB9LFxuICBmeDoge1xuICAgIEZ4QmFzZTogRnhCYXNlLFxuICAgIERlYnVnZ2VyOiBEZWJ1Z2dlcixcbiAgICBGeFNjYW5uZXI6IEZ4U2Nhbm5lcixcbiAgICAvLyBHbGl0Y2hBcHBlYXIsXG4gICAgLy8gR2xpdGNoSW5PdXQsXG4gICAgLy8gR2xpdGNoQ2FudmFzLFxuICAgIC8vIEdsaXRjaEVhc2VsLFxuICAgIEZpdDogRml0LFxuICAgIEdsaXRjaDogR2xpdGNoLFxuICAgIE1hZ25ldDogTWFnbmV0LFxuICAgIEhpZGU6IEhpZGUsXG4gICAgQXBwZWFyOiBBcHBlYXIsXG4gICAgSW52aXNpYmxlOiBJbnZpc2libGUsXG4gICAgTm9Qb2ludGVyRXZlbnRzOiBOb1BvaW50ZXJFdmVudHMsXG4gICAgTG90dGllOiBMb3R0aWUsXG4gICAgUGFyYWxsYXg6IFBhcmFsbGF4LFxuICAgIFBhcnRpY2xlczogUGFydGljbGVzLFxuICAgIEhhbmRDdXJzb3I6IEhhbmRDdXJzb3IsXG4gICAgSnVtcDogSnVtcCxcbiAgICBUeXBlQW5pbWF0aW9uOiBUeXBlQW5pbWF0aW9uLFxuICAgIFR5cGVTcGluOiBUeXBlU3BpbixcbiAgICBTcHJpdGVzaGVldDogU3ByaXRlc2hlZXQsXG4gICAgUmVtb3ZlOiBSZW1vdmUsXG4gICAgRmFkZTogRmFkZSxcbiAgICBQYW5ab29tOiBQYW5ab29tLFxuICAgIFlvdVR1YmU6IFlvdVR1YmUsXG4gICAgSUZyYW1lOiBJRnJhbWUsXG4gICAgU2VxdWVuY2U6IFNlcXVlbmNlLFxuICAgIFRleHRJbnB1dDogVGV4dElucHV0LFxuICAgIFJlcGVhdEdyaWQ6IFJlcGVhdEdyaWQgLy8gZXg6IHtcbiAgICAvLyAgIGFuaW1lOiB7XG4gICAgLy8gICAgIE1hZ25ldDogQW5pbWVNYWduZXRcbiAgICAvLyAgIH1cbiAgICAvLyB9ICBcblxuICB9XG59KTsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n')}]);